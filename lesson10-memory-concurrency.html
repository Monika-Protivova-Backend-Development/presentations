<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="./src/dist/reset.css">
	<link rel="stylesheet" href="./src/dist/reveal.css">
	<link rel="stylesheet" href="./src/dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="./src/plugin/highlight/vs.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-gradient="var(--kotlin-gradient)">
			<i>Week 3 | Lesson 10</i>
			<h1>Memory & Threads</h1>
			<em>JVM, JRE, JDK, compiler</em><br />
			<em>Memory management</em><br />
			<em>Multithreading</em><br />
			<em>Coroutines ♡</em>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Java Virtual Machine</h2>
				<em>JVM</em>
			</section>
			<section>
				<h3>Java Virtual Machine</h3>
				<div class="summary">
					"Write Once, Run Anywhere"
				</div>
				<div class="content">
					<ul>
						<li>
							The main purpose of JVM is to provide a runtime environment for Java applications,
							that is independent of the underlying hardware and operating system.
							<br />
							<br />
						</li>
						<li>
							Other programming languages that can run on JVM include <strong class="highlight">Kotlin</strong>, <strong class="highlight">Scala</strong>, <strong class="highlight">Groovy</strong> and <strong class="highlight">Clojure</strong>.
							<br />
							<br />
						</li>
						<li>
							JVM also provides tools for runtime performance optimization, memory management (garbage collection), monitoring, and other.
							<br />
							<br />
						</li>
						<li>
							Java Virtual Machine is a part of the Java Runtime Environment (JRE).
							<br />
							<br />
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Java Virtual Machine</h3>
				<div class="summary">
					There are three ways to look at JVM implementations.
				</div>
				<div class="content">
					<ol>
						<li>
							<strong class="highlight">Specification</strong><br />
							Defines how the JVM should be implemented.
						</li>
						<li>
							<strong class="highlight">Implementation</strong><br />
							The actual JVM implementation.
						</li>
						<li>
							<strong class="highlight">Instance</strong><br />
							A running JVM process (create every time you start a Java program).
						</li>
					</ol>
					<p>
						Since JVM is open source, it exists in more than one implementation.
						They all follow the specification, but may differ in performance, memory management, and other aspects.
					</p>
					<p>
						Some of the most popular JVM implementations are:
					</p>
					<ul>
						<li>Oracle HotSpot JVM</li>
						<li>Eclipse OpenJ9</li>
						<li>GraalVM</li>
					</ul>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>JRE, JDK, compiler</h2>
			</section>
			<section>
				<h3>JRE, JDK, compiler</h3>
				<div class="content">
					<p>
						<strong class="highlight">JRE - Java Runtime Environment</strong><br />
						JRE is the part of Java required to run Java applications. It includes JVM, core libraries, and other components.
						If you only want to run Java applications, you only need JRE.
					</p>
					<p>
						<strong class="highlight">JDK - Java Development Kit</strong><br />
						You need JDK if you want to develop Java applications. It includes JRE, compiler, and other development tools.
					</p>
					<p>
						<strong class="highlight">Java Compiler</strong><br />
						Java source code is compiled into <strong class="highlight">bytecode</strong>, which is then executed by JVM. To do so, you need a Java compiler.
					</p>
					<p>
						<strong class="highlight">Java Bytecode</strong><br />
						Java bytecode is the instruction set for the Java Virtual Machine.
					</p>
				</div>
			</section>
			<section>
				<h3>Java Bytecode</h3>
				<div class="summary">Write Once, Run Anywhere</div>
				<div class="content">
					<p>
						Java bytecode is the intermediate representation of Java code which is output by the Java compiler (javac).
						It is not the machine code for any particular computer - it is not executed by the CPU of any computer.
					</p>
					<p>
						Instead, the Java bytecode is executed by the Java Virtual Machine (JVM).
						You can say it is an instruction set for the JVM.
					</p>
				</div>
			</section>
			<section>
				<h3>Java Bytecode</h3>
				<div class="summary">Write Once, Run Anywhere</div>
				<div class="content">
					<p>
						When a Java program is compiled, each individual class file is compiled into a separate bytecode file (with a .class extension).
						This bytecode is platform independent, which means the same bytecode can run on any device that has a JVM.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main(args: Array&lt;String&gt;) {
								println("Hello, World!")
							}
						</code>
					</pre>
					<p>
						Compiles to following bytecode:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="">
							Compiled from "HelloWorld.java"
							public class lesson08.HelloWorld {
							  public lesson08.HelloWorld();
								Code:
								   0: aload_0
								   1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
								   4: return

							  public static void main(java.lang.String[]);
								Code:
								   0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
								   3: ldc           #13                 // String Hello, World!
								   5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
								   8: return
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Java Memory Management</h2>
			</section>
			<section>
				<h3>Java Memory Management</h3>
				<div class="summary">
					Java memory management is to a large extent automatic.
				</div>
				<div class="content">
					<p>
						Automatic memory management was one of the key features of Java when it was first introduced.
					</p>
					<p>
						As your program runs, the JVM automatically allocates and de-allocates memory for variable,
						objects, methods and other data structures.
					</p>
					<p>
						The deallocation process is known as <strong class="highlight">garbage collection (GC)</strong>,
						and the process responsible for it is called the <strong class="highlight">garbage collector</strong>.
					</p>
					<p>
						Java <strong class="highlight">GC</strong> helps us to avoid memory leaks and optimize memory usage.
					</p>
					<p>
						However, some memory leaks can still occur due to programming errors.
						<em>(By not releasing references to objects that are no longer needed.)</em>
					</p>
				</div>
			</section>
			<section>
				<h3>Java Memory Layout</h3>
				<div class="summary">
					There are several types of memory spaces in Java, each serving a different purpose.
				</div>
				<div class="content">
					<pre style="font-size: 60%; line-height: 1.3em;">
+---------------------------------------------+
|                  JVM Memory                 |
+---------------------------------------------+
|           Method Area (MetaSpace)           | ← Stores class metadata, method info, static variables
|                                             |   - Loaded class definitions
|                                             |   - Method and field descriptors
|                                             |   - Runtime constant pool
|                                             |   - Shared across all threads
+---------------------------------------------+
|                   Heap                      | ← Stores all class instances and arrays
|                                             |   - Object fields and values
|                                             |   - Managed by Garbage Collector
|                                             |   - Shared across all threads
+---------------------------------------------+
|             Stack (one per thread)          | ← Stores frames for active method calls
|                                             |   - Method arguments and return values
|                                             |   - Local variables and references
|                                             |   - Each thread has its own stack
+---------------------------------------------+
|          Native Method Stack                | ← Used by native (non-Java) methods
|                                             |   - Platform-specific, unmanaged by JVM GC
+---------------------------------------------+
|         Program Counter (PC) Register       | ← Tracks JVM bytecode instruction per thread
|                                             |   - One per thread
|                                             |   - Points to the current instruction
+---------------------------------------------+
					</pre>
				</div>
			</section>
			<section>
				<h3>MetaSpace</h3>
				<div class="summary">
					MetaSpace is a memory area in the JVM that stores class metadata.
					It is used to store information about classes, methods, and fields.
				</div>
				<div class="content">
					<p>
						MetaSpace memory is allocated when:
					</p>
					<ul>
						<li>Classes are loaded by the JVM when they are referenced in the code.</li>
						<li>Methods are compiled by the JVM when they are called for the first time.</li>
						<li>Static variables are initialized when the class is loaded.</li>
						<li>...</li>
					</ul>
					<p>
						MetaSpace is garbage collected just like the heap memory.
					</p>
					<p>
						The size of MetaSpace can be controlled using the following JVM options:
					</p>
					<ul>
						<li><code class="inline">-XX:MetaspaceSize</code> - sets the initial size of MetaSpace</li>
						<li><code class="inline">-XX:MaxMetaspaceSize</code> - sets the maximum size of MetaSpace</li>
					</ul>
					<p>
						<sub>
							MetaSpace is a replacement for the Permanent Generation (PermGen) space in older JVM versions.
							It is allocated in native memory, which means it is not limited by the heap size.
						</sub>
					</p>
				</div>
			</section>
<!--			<section>-->
<!--				<h3>MetaSpace (Java 8+)</h3>-->
<!--				<div class="content">-->
<!--					<ul>-->
<!--						<li>Replaces <code>PermGen</code> (used in older Java versions)</li>-->
<!--						<li>Stores JVM class metadata (class definitions, method info, etc.)</li>-->
<!--						<li>Located in <strong>native memory</strong>, not JVM heap</li>-->
<!--						<li>Grows dynamically (no more <code>OutOfMemoryError: PermGen</code>)</li>-->
<!--						<li>Still GC-managed — classes can be unloaded</li>-->
<!--					</ul>-->
<!--					<p><strong>Flags:</strong></p>-->
<!--					<ul>-->
<!--						<li><code>-XX:MetaspaceSize=128m</code> (initial)</li>-->
<!--						<li><code>-XX:MaxMetaspaceSize=512m</code> (max)</li>-->
<!--					</ul>-->
<!--					<p><strong>Why it matters:</strong> Prevents classloader-related memory leaks, improves GC behavior, and better handles large modular apps.</p>-->
<!--				</div>-->
<!--			</section>-->
			<section>
				<h3>Heap</h3>
				<div class="summary">
					Heap memory is where all objects (instances of classes) are stored.
					<br />
					Each time an object is created, memory is allocated on the heap at runtime.
				</div>
				<div class="content">
					<p>
						Heap memory is shared among all threads, and it is the memory area is maintained by the garbage collector.
					</p>
					<p>
						Heap memory is divided into two main areas:
					</p>
					<ul>
						<li><strong class="highlight">Young Generation</strong> - where new objects are created</li>
						<li><strong class="highlight">Old Generation</strong> - where long-lived objects are stored</li>
					</ul>
					<p>
						Heap memory is used for dynamic memory allocation, which means that the size of the heap can grow and shrink during the execution of the program.
					</p>
					<p>
						Heap memory is managed by the garbage collector, which automatically reclaims memory that is no longer needed.
					</p>
					<p>
						You can control the size of the heap using following options:
					</p>
					<ul>
						<li><code class="inline">-Xms</code> sets the initial size of the heap</li>
						<li><code  class="inline">-Xmx</code> sets the maximum size of the heap</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Stack</h3>
				<div class="summary">

				</div>
				<div class="content">
					<p>
						Stack memory is used to store:
					</p>
					<ul>
						<li>
							Method frames (call stack)
<!--							<br />-->
<!--							<sub>-->
<!--								Method frame is a data structure that contains information about the method call, such as method arguments, local variables, and return address.-->
<!--							</sub>-->
						</li>
						<li>Local variables and parameters of methods</li>
						<li>Primitive values (int, float, etc.)</li>
						<li>References to objects in heap space</li>
					</ul>
					<p>
						Stack memory is allocated when a method is called and deallocated when the method returns.
					</p>
					<p>
						Each thread in Java has its own JVM stack which is created at the same time as the thread.
					</p>
					<p>
						Stack memory has a specific size and is not directly controlled by the programmer.
					</p>
					<p>
						Properties of stack are:
					</p>
					<ul>
						<li>Fast access</li>
						<li>Automatically managed (cleared when function ends)</li>
						<li>Exists per thread</li>
						<li>Cannot grow too big (overflow → StackOverflowError)</li>
					</ul>
					<p>
						Method frame ...
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun sum(a: Int, b: Int): Int {
								val result = a + b
								return result
							}
						</code>
					</pre>
					<pre>
Method Frame (for sum):
+-----------------------+
| return address        |
| a = 3                 |
| b = 4                 |
| result = 7            |
| operand stack         |
+-----------------------+
					</pre>
				</div>
			</section>
			<section>
				<h3>Difference Between Stack and Heap</h3>
				<div class="summary"></div>
				<div class="content">
					<div class="row">
						<div class="column">
							<strong class="highlight">Stack</strong>
							<ul>
								<li>Stores method frames, local variables, and primitive values</li>
								<li>Memory is allocated and deallocated automatically</li>
								<li>Fast access, but limited size</li>
								<li>Each thread has its own stack</li>
								<li>Used for method calls and local variables</li>
							</ul>
						</div>
						<div class="column">
							<strong class="highlight">Heap</strong>
							<ul>
								<li>Stores objects and arrays</li>
								<li>Memory is managed by the garbage collector</li>
								<li>Slower access, but larger size</li>
								<li>Shared among all threads</li>
								<li>Used for dynamic memory allocation</li>
							</ul>
						</div>
						<div class="column"></div>
					</div>
				</div>
			</section>
			<section>
				<h3>Memory Allocation Examples</h3>
				<div class="content" style="font-size: 70%;">
					<div class="row">
						<div class="column">
							<strong class="highlight">1. Primitive Types → Stack (when local)</strong>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									fun main() {
										val a = 42      // Int – primitive value, allocated on stack
										val b = true    // Boolean – also on stack
									}
								</code>
							</pre>
							<ul style="font-size: 60%;">
								<li>These variables are local to the main function → stored in the stack frame.</li>
								<li>No object instantiation → no heap allocation.</li>
							</ul>
						</div>
						<div class="column">
							<strong class="highlight">2. Reference Types (Classes) → Heap</strong>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									class User(val name: String)

									fun main() {
										val user = User("Alice") // user is a reference on stack, actual User object on heap
									}
								</code>
							</pre>
							<ul style="font-size: 60%;">
								<li>List reference → stack</li>
								<li>Actual List and its contents → heap</li>
								<li>Returned to caller → remains alive after function ends</li>
							</ul>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<strong class="highlight">3. Function-local Objects → Heap</strong>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									fun createList(): List&lt;Int&gt; {
										val list = listOf(1, 2, 3) // list is a reference on stack, actual List on heap
										return list
									}
								</code>
							</pre>
							<ul style="font-size: 60%;">
								list reference → stack
								•	actual List and its contents → heap
								•	returned to caller → remains alive after function ends
							</ul>
						</div>
						<div class="column">
							<strong class="highlight">4. Objects Captured in Lambdas → Heap</strong>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									fun main() {
										val prefix = "Item " // captured in lambda → stored on heap
										val printer = { i: Int -> println(prefix + i) }

										printer(5)
									}
								</code>
							</pre>
							<ul style="font-size: 60%;">
								<li>Lambdas that capture variables allocate a closure object on the heap.</li>
								<li>If prefix were not captured, lambda could be compiled more efficiently.</li>
							</ul>
						</div>
					</div>

					<div class="row">
						<div class="column">
							<strong class="highlight">5. Top-Level / object Singleton → Heap (once)</strong>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									object Logger {
										fun log(msg: String) {
											println(msg)
										}
									}
								</code>
							</pre>
							<ul style="font-size: 60%;">
								<li>The Logger object is allocated once and lives in heap/meta space.</li>
								<li>Static-like structure with JVM guarantees.</li>
							</ul>
						</div>
						<div class="column">
							<strong class="highlight">6. Array Allocation → Heap</strong>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									val nums = IntArray(5) // array is always allocated on heap
								</code>
							</pre>
							<ul style="font-size: 60%;">
								<li>Arrays, even of primitives, live on heap.</li>
								<li>Elements of primitive type (Int) are stored inline; objects would be references.</li>
							</ul>
						</div>
					</div>
					<div class="row">
						<div class="column">
							<strong class="highlight">7. Inline Functions and Reified Types → Reduced Allocation</strong>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									inline fun &lt;reified T&gt; printType() {
										println(T::class.java.name)
									}
								</code>
							</pre>
							<ul style="font-size: 60%;">
								<li>Inlined at call site → may reduce allocation.</li>
								<li>No closure or lambda object if no capturing → no heap cost.</li>
							</ul>
						</div>
						<div class="column"></div>
					</div>

				</div>
			</section>
			<section>
				<h3>Memory Allocation Examples</h3>
				<div class="summary">
					Here are some examples of what to avoid when allocating memory.
				</div>
				<div class="content">
					<h4>Example: Memory Leak Due to Static Reference</h4>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							object Leaky {
								var cache: MutableList&lt;Any&gt; = mutableListOf()
							}

							fun main() {
								repeat(1_000_000) {
									Leaky.cache.add(ByteArray(1024 * 1024)) // 1MB
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Garbage Collection</h3>
				<div class="summary">
					Garbage Collection (GC) is a process of automatically reclaiming memory.
				</div>
				<div class="content">
					<p>
						The Garbage Collector automatically frees up heap space memory allocations that are no longer
						referenced by any running part of the program.
					</p>
					<p>
						The process of GC is not predictable, and the programmer can’t force garbage collection.
						System.gc() can be called as a hint to JVM for garbage collection, but it is not guaranteed that it will be performed.
					</p>
					<p>
						To make the garbage collection process more efficient, the heap is divided into generations.
					</p>
					<ul>
						<li>
							<span class="highlight">Young Generation (Eden)</span><br />
						</li>
						<li>
							<span class="highlight">Old Generation (Tenured)</span><br />
						</li>
						<li>
							<span class="highlight">Meta Space</span><br />
						</li>
					</ul>
					<p>
						Java uses a generational garbage collection strategy that categorizes objects by age.
						This is because performing GC on the entire heap would be inefficient.
						Most objects in Java are short-lived; therefore, there can be more frequent GC events for those.
					</p>
				</div>
			</section>
			<section>
				<h3>Garbage Collection Generations</h3>
				<div class="content">
					<div class="row">
						<div class="column">
							<ul>
								<li>
									<span class="highlight">Young Generation (Eden)</span><br />
									This is where all new objects are created. It can be further divided into Eden space and Survivor spaces (FromSpace and ToSpace).
									<ul>
										<li>When it fills up, a Minor GC event occurs.</li>
										<li>Objects that are evaluated as dead or alive.</li>
										<li>Dead objects are removed, and the memory is compacted.</li>
										<li>If an object survives for a given number minor GC cycles, it is promoted to the Old Generation.</li>
									</ul>
								</li>
								<li>
									<span class="highlight">Old Generation (Tenured)</span><br />
									This contains objects that have survived the garbage collection from the Young Generation.
								</li>
								<li>
									<span class="highlight">Meta Space</span><br />
									Stores class metadata and is GC-managed, but separate from the heap and generational GC.
								</li>
							</ul>
						</div>
						<div class="column">
							<pre style="font-size: 60%; line-height: 1.3em;">
+-------------------------------------------------------------+
|                    Young Generation                         |
| - New objects are created here                              |
| - Frequent GC (Minor GC)                                    |
|                                                             |
| +--------------------+ +----------------+ +---------------+ |
| |      Eden Space    | |  Survivor S0   | | Survivor S1   | |
| |  - All new objects | |  - After GC,   | |  - Used as    | |
| |    allocated here  | |    surviving   | |    swap space | |
| |                    | |    objects move| |    in next    | |
| |  - GC clears this  | |    here        | |    GC round   | |
| +--------------------+ +----------------+ +---------------+ |
|                                                             |
|  ↳ Minor GC: clears Eden, moves surviving objects ↔ S0/S1   |
|  ↳ After several GC cycles, surviving objects promoted ↓    |
+-----------------------------+-------------------------------+
                              |
                              v
+-------------------------------------------------------------+
|                   Old Generation (Tenured)                  |
| - Long-living objects reside here                           |
| - Infrequent GC (Major GC or Full GC)                       |
| - Larger memory footprint                                   |
|                                                             |
| ↳ Promotion happens when object survives multiple GC        |
| ↳ GC here is slower and causes application pauses           |
+-----------------------------+-------------------------------+
                              |
                              v
+-------------------------------------------------------------+
|             MetaSpace (was: Permanent Generation)           |
| - Stores class metadata and method information              |
| - Classloader info, static fields, etc.                     |
| - Not part of the heap (since Java 8)                       |
|                                                             |
| ↳ Still GC-managed, but independently of heap objects       |
+-------------------------------------------------------------+
  							</pre>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Garbage Collection Strategies</h3>
				<div class="summary">
					There is a number of GC strategies that can be used in Java.
					Each strategy has its own advantages and disadvantages, and is suitable for different types of applications.
				</div>
				<div class="content">
					<ul>
						<li>Serial Collector <code class="inline">-XX:+UseSerialGC</code></li>
						<li>Parallel Collector <code class="inline">-XX:+UseParallelGC</code> and <code class="inline">-XX:+UseParallelOldGC</code></li>
						<li>Concurrent Mark Sweep (CMS) Collector <code class="inline">-XX:+UseConcMarkSweepGC</code></li>
						<li>G1 (Garbage-First) Collector <code class="inline">-XX:+UseG1GC</code></li>
						<li>Shenandoah GC <code class="inline">-XX:+UseShenandoahGC</code></li>
					</ul>
					<p>
						Each JVM implementation may implement GC differently, and may have its own GC strategies,
						although they should all follow the JVM specification.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Multithreading</h2>
			</section>
			<section>
				<h3>Multithreading</h3>
				<div class="summary">
					Multithreading allows execution of multiple parts of a program concurrently,
					using lightweight processes called threads. It aims to maximize the use of CPU time.
				</div>
				<div class="content">
					<p>
						Generally, there is always at least one thread running in a Java program - the <strong class="highlight">main</strong> thread.
					</p>
					<p>
						To create a new thread, need to create new instance <code class="inline">Thread</code> class.
						To start a thread, need to call its <code class="inline">start()</code> method of the <code class="inline">Thread</code> class instance.
					</p>
					<p>
						Another way to create a thread is by implementing the <code class="inline">Runnable</code> interface and passing an instance of it to a new thread.
					</p>
					<p>
						Alternatively, we can use the <strong class="highlight">Executor Framework</strong> provided by <code class="inline">java.util.concurrent</code>.
					</p>
					<p>
						Synchronization in Java / Kotlin is an important feature that allows only one thread to have access to the shared resource.
					</p>
				</div>
			</section>
			<section>
				<h3>Thread</h3>
				<div class="summary">
					The Java way.
				</div>
				<div class="content">
					<p>
						<code class="inline">Thread</code>> is a class in Java that allows you to create and manage threads.
						You can create thread directly, or by extending the <code class="inline">Thread</code>
						class and overriding the <code class="inline">run()</code>> method.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {

								val thread = Thread {
									println("Hello from '${Thread.currentThread().name}' thread")
								}

								thread.start()

								println("Hello from '" + Thread.currentThread().name + "' thread")
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								MyThread().start()
							}

							class MyThread : Thread() {
								override fun run() {
									println("Hello from '${currentThread().name}' thread");
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Thread</h3>
				<div class="content">
					<p>
						Thread is started by calling the <code class="inline">start()</code> method.
						When the <code class="inline">start()</code> method is called, the JVM calls the <code class="inline">run()</code> method of the thread.
					</p>
					<p>
						When the <code class="inline">run()</code> method finishes, the thread is considered to be terminated.
					</p>
					<p>
						If at any time you want to stop a thread, you can call the <code class="inline">interrupt()</code> method.
					</p>
					<p>
						To wait for a thread to finish, you can call the <code class="inline">join()</code> method.
						However, beware that this will block the current thread until the other thread finishes.
					</p>
				</div>
			</section>
			<section>
				<h3>Thread</h3>
				<div class="summary">
					The Kotlin way
				</div>
				<div class="content">
					<p>
						While we use Java <code class="inline">Thread</code> class in Kotlin, as usual, Kotlin
						provides a more concise way to create and manage threads.
					</p>
					<p>
						You can use the <code class="inline">thread</code> function to create a new thread.
					</p>
					<p>
						The function simplifies the creation of a new thread by allowing you to configure the thread properties in a more concise way.
						The arguments available are:
					</p>
					<ul>
						<li><code class="inline">start: Boolean = true</code> - start the thread immediately</li>
						<li><code class="inline">isDaemon: Boolean = false</code> - create a daemon thread</li>
						<li><code class="inline">contextClassLoader: ClassLoader? = null,</code> - class loader to use for loading classes and resources</li>
						<li><code class="inline">name: String? = null,</code> - name of the thread</li>
						<li><code class="inline">priority: Int = -1,</code> - priority of the thread</li>
						<li><code class="inline">block: () -> Unit</code> - code to be executed in the thread</li>
					</ul>

					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								thread(start = true, isDaemon = true, name = "my-thread", priority = 999) {
									println("Hello from '${Thread.currentThread().name}' thread")
								}

								println("Hello from '" + Thread.currentThread().name + "' thread")
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Runnable</h3>
				<div class="summary">
					<strong class="highlight">Runnable</strong> is an interface in Java that allows you to create and manage threads.
				</div>
				<div class="content">
					<p>
						To use <strong class="highlight">Runnable</strong>, you pass an instance of <strong class="highlight">Runnable</strong> to a new <strong class="highlight">Thread</strong>.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class MyRunnable : Runnable {
								override fun run() {
									println("Hello from '${Thread.currentThread().name}' thread")
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val thread = Thread(MyRunnable(), "Runner 1")

								println("Starting thread '${thread.name}'")

								thread.start()

								try {
									// this will block the main thread until the other thread finishes
									thread.join()
								} catch (e: InterruptedException) {
									Thread.currentThread().interrupt()
									throw RuntimeException(e)
								}

								println("Thread '${thread.name}' finished")
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Memory Synchronization</h3>
				<div class="summary">
					Memory synchronization ensures that the changes made by one thread to the shared data are visible to other threads.
				</div>
				<div class="content">
					<ul>
						<li>
							<code class="inline">@Volatile</code><br />
							<p>
								Used to mark a field as volatile to the JVM.
								It ensures that all reads of a volatile variable are read directly from main memory,
								and all writes to a volatile variable are written directly to main memory.
								By itself, volatile does not provide atomicity, but it ensures visibility.
							</p>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									@Volatile
									private var flag: Boolean = true
								</code>
							</pre>
						</li>
						<li>
							<code class="inline">@Synchronized</code><br />
							<p>
								If <strong class="highlight">method</strong> is synchronized, only one thread can access the method or block at a time.
								This ensures that the changes made by one thread to the shared data are visible to other threads.
							</p>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									@Synchronized
									fun someMethod() {
										// ...
									}
								</code>
							</pre>
						</li>
						<li>
							<code class="inline">synchronized</code> block<br />
							<p>
								You can also use synchronized block to synchronize access to shared data within a block of code.
							</p>
							<p>
								<em>
									The difference between <code class="inline">@Synchronized</code>
									and <code class="inline">synchronized</code> block is that the former is used to synchronize a method,
									while the latter is used to synchronize a block of code.
									Synchronizing on method level can be more efficient than synchronizing on block level, especially if the code is called frequently,
									because <code class="inline">synchronized</code> needs to acquire and release the lock every time the method is called.
								</em>
							</p>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Memory Synchronization</h3>
				<div class="content">
					<blockquote class="warning">
						Remember that incorrect synchronization can lead to issues like race conditions, deadlocks or even data inconsistency.
						It advised to avoid shared mutable data for threads and use thread confinement or immutability.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Memory Synchronization</h3>
				<div class="summary">
					No synchronization - NOT thread safe!
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							var sharedCounter = 0

							fun main() {

								val thread1 = Thread(::incrementCounter)
								val thread2 = Thread(::incrementCounter)

								thread1.start()
								thread2.start()

								// wait for both threads to finish
								thread1.join()
								thread2.join()

								println("Final Counter Value: $sharedCounter")
							}

							fun incrementCounter() {
								repeat(1000) {
									sharedCounter++
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Memory Synchronization</h3>
				<div class="summary">
					With synchronization using <code class="inline">@Synchronized</code> - thread safe.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@Volatile // doesn't ensure atomicity, but ensures visibility
							var sharedCounter = 0

							fun main() {

								val thread1 = thread { incrementCounter() }
								val thread2 = thread { incrementCounter() }

								thread1.start()
								thread2.start()

								// wait for both threads to finish
								thread1.join()
								thread2.join()

								println("Final Counter Value: $sharedCounter")
							}

							@Synchronized // ensures that only one thread can execute this function at a time, acquire lock on whole function
							fun incrementCounter() {
								repeat(1000) {
									sharedCounter++
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Memory Synchronization</h3>
				<div class="summary">
					With synchronization with <code class="inline">synchronized</code> function - thread safe.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@Volatile // doesn't ensure atomicity, but ensures visibility
							var sharedCounter = 0

							fun main() {

								val thread1 = thread { incrementCounter() }
								val thread2 = thread { incrementCounter() }

									thread1.start()
									thread2.start()

									// wait for both threads to finish
									thread1.join()
									thread2.join()

								println("Final Counter Value: $sharedCounter")
							}

							private val lock = Any() // because incrementCounter is a top-level function, we need and container object to lock on

							fun incrementCounter() {
								repeat(1000) {
									synchronized(lock) { // ensures atomicity, acquire lock on this object
										sharedCounter++
									}
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>java.util.concurrent</h3>
				<div class="summary">
					Besides the low-level synchronization mechanisms such as <code class="inline">volatile</code> and <code class="inline">synchronized</code> keywords,
					Java provides a number of classes and interfaces in the <code class="inline">java.util.concurrent</code> package to help with multithreading.
				</div>
				<div class="content">
					<p>
						The package includes:
					</p>
					<ul>
						<li><strong class="highlight">Atomic Variables</strong></li>
						<li><strong class="highlight">Synchronizers</strong></li>
						<li>Concurrent Collections</li>
						<li>Locks</li>
						<li>Callable and Future</li>
						<li>Executor Framework</li>
					</ul>
				</div>

			</section>
			<section>
				<h3>Atomic Variables</h3>
				<div class="summary">
					The <code class="inline">java.util.concurrent</code> package defines classes that support atomic operations on single variables.
					All atomic operations are thread-safe.
				</div>
				<div class="content">
					<p>
						There are several classes in this package, for example <strong class="highlight">AtomicBoolean</strong>,
						<strong class="highlight">AtomicInteger</strong>, <strong class="highlight">AtomicLong</strong>, etc.
					</p>
					<p>
						Here is what you can do with atomic variables ...
					</p>
				</div>
			</section>
			<section>
				<h3>Atomic Variables</h3>
				<div class="content">
					<p>
						<strong class="highlight">Atomic Read and Write</strong><br />
						You can read or write the value of atomic variables in a thread-safe manner. When you update an atomic variable, it ensures that the new value is immediately visible to other threads.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val atomicInteger = AtomicInteger(0)
							atomicInteger.set(78)
							val value = atomicInteger.get()
						</code>
					</pre>
					<p>
						<strong class="highlight">Atomic Update</strong><br />
						This allows you to atomically update the value of atomic variables. For Atomic integers and longs, it includes methods to increment, decrement, and add a certain value atomically.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val atomicInteger = AtomicInteger(0)
							atomicInteger.incrementAndGet()
							atomicInteger.addAndGet(46)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Atomic Variables</h3>
				<div class="content">
					<p>
						<strong class="highlight">Compare and Set/Swap (CAS)</strong><br />
						It enables you to update the value of a variable only when it has a certain expected value. It’s a way of managing concurrency, without traditional lock-based synchronization.
						For example, to atomically update a value only if it's currently equal to 10, you can use:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val atomicInteger = AtomicInteger(10)
							val updated = atomicInteger.compareAndSet(10, 78)
						</code>
					</pre>
					<p>
						<strong class="highlight">getAndIncrement, getAndDecrement, getAndAdd</strong><br />
						These are atomic operations that atomically increment, decrement, or add the value and return the old value.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val atomicInteger = AtomicInteger(0)
							val oldValue = atomicInteger.getAndIncrement()
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Atomic Variables</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							import java.util.concurrent.atomic.AtomicInteger
							import kotlin.concurrent.thread

							private val counter = AtomicInteger(10)

							fun main() {

								thread(name = "thread-1") {
									while (counter.getAndDecrement() > 0) {
										println("Hello from '" + Thread.currentThread().name + "' thread. Counter = ${counter.get()}");
									}
								}

								thread(name = "thread-2") {
									while (counter.getAndDecrement() > 0) {
										println("Hello from '" + Thread.currentThread().name + "' thread. Counter = ${counter.get()}");
									}
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Hello from 'thread-1' thread. Counter = 9
							Hello from 'thread-1' thread. Counter = 7
							Hello from 'thread-1' thread. Counter = 6
							Hello from 'thread-2' thread. Counter = 8
							Hello from 'thread-1' thread. Counter = 5
							Hello from 'thread-1' thread. Counter = 3
							Hello from 'thread-1' thread. Counter = 2
							Hello from 'thread-1' thread. Counter = 1
							Hello from 'thread-1' thread. Counter = 0
							Hello from 'thread-2' thread. Counter = 4
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Synchronizers</h3>
				<div class="content">
					<ul>
						<li>
							<strong class="highlight">Semaphore</strong><br />
							It controls the access to a shared resource through the use of a counter. If the counter is greater than zero, the access is allowed, otherwise the access is denied. This is often used to limit the number of threads that can access a particular resource.
						</li>
						<li>
							<strong class="highlight">CountDownLatch</strong><br />
							It allows one or more threads to wait until a set of operations being performed in other threads completes. Once the count is zero, all waiting threads proceed. It's a one-time phenomenon, once the latch reaches zero it cannot be reset.
						</li>
						<li>
							<strong class="highlight">CyclicBarrier</strong><br />
							It's used when multiple threads carry out different sub tasks and the output of these sub tasks need to be combined to form the final output. It's called cyclic because it can be reused after waiting threads are released.
						</li>
						<li>
							<strong class="highlight">Phaser</strong><br />
							It's more flexible than both CountDownLatch and CyclicBarrier. It's called Phaser because it phases all the threads into stages of execution.
						</li>
						<li>
							<strong class="highlight">Exchanger</strong><br />
							It's used to exchange data between two threads. It waits for both the threads to reach the exchange point. If the threads do not appear simultaneously to exchange their objects, they'll be paused until the arrival of the other thread.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Semaphore</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							import java.util.concurrent.Semaphore
							import kotlin.concurrent.thread

							private val semaphore = Semaphore(1)

							fun main() {
								thread(name = "A") { execute(semaphore) }
								thread(name = "B") { execute(semaphore) }
							}

							fun execute(semaphore: Semaphore) {
								try {
									semaphore.acquire()
									println("Thread '" + Thread.currentThread().name + "' acquired the semaphore")
								} catch (e: InterruptedException) {
									Thread.currentThread().interrupt()
									throw RuntimeException(e)
								} finally {
									println("Thread '" + Thread.currentThread().name + "' is releasing the semaphore")
									semaphore.release()
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Thread 'A' acquired the semaphore
							Thread 'A' is releasing the semaphore
							Thread 'B' acquired the semaphore
							Thread 'B' is releasing the semaphore
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>CountDownLatch</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {

								thread(name = "WAITING") {
									println("Thread '${Thread.currentThread().name}' started")
									try {
										latch.await()
									} catch (e: InterruptedException) {
										Thread.currentThread().interrupt()
										throw RuntimeException(e)
									}
									println("Thread '${Thread.currentThread().name}' finished")
								}

								thread(name = "COUNTING") {
									println("Thread '${Thread.currentThread().name}' started")
									while (latch.count > 0) {
										println("Thread '${Thread.currentThread().name}' counting down ${latch.count}...")
										latch.countDown()
									}
									println("Thread '${Thread.currentThread().name}' finished")
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Thread 'COUNTING' started
							Thread 'WAITING' started
							Thread 'COUNTING' counting down 3...
							Thread 'COUNTING' counting down 2...
							Thread 'COUNTING' counting down 1...
							Thread 'COUNTING' finished
							Thread 'WAITING' finished
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>CyclicBarrier</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							import java.util.concurrent.CyclicBarrier
							import kotlin.concurrent.thread

							private var barrier = CyclicBarrier(3) { println("Barrier reached") }

							fun main() {
								thread(name = "A") { execute(barrier) }
								thread(name = "B") { execute(barrier) }
								thread(name = "C") { execute(barrier) }
							}

							fun execute(barrier: CyclicBarrier) {
								try {
									println("Thread '${Thread.currentThread().name}' is waiting on the barrier")
									barrier.await()
									println("Thread '${Thread.currentThread().name}' has passed the barrier")
								} catch (e: Exception) {
									throw RuntimeException(e)
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Thread 'C' is waiting on the barrier
							Thread 'B' is waiting on the barrier
							Thread 'A' is waiting on the barrier
							Barrier reached
							Thread 'A' has passed the barrier
							Thread 'C' has passed the barrier
							Thread 'B' has passed the barrier
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Phaser</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							import java.util.concurrent.Phaser
							import kotlin.concurrent.thread

							private val phaser = Phaser(2)

							fun main() {
								thread(name = "PRE-PROCESSOR") { preProcessor(phaser) }
								thread(name = "POST-PROCESSOR") { postProcessor(phaser) }
							}

							fun postProcessor(phaser: Phaser) {
								println("Thread '${Thread.currentThread().name}' has arrived. Waiting for others...")
								phaser.arriveAndAwaitAdvance()
								println("Thread '${Thread.currentThread().name}' has finished.")
							}

							fun preProcessor(phaser: Phaser) {
								try {
									Thread.sleep(1000)
								} catch (e: InterruptedException) {
									Thread.currentThread().interrupt()
									throw RuntimeException(e)
								}
								println("Thread '${Thread.currentThread().name}' has arrived.")
								phaser.arriveAndDeregister()
								println("Thread '${Thread.currentThread().name}' has finished.")
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Thread 'POST-PROCESSOR' has arrived. Waiting for others...
							Thread 'PRE-PROCESSOR' has arrived.
							Thread 'PRE-PROCESSOR' has finished.
							Thread 'POST-PROCESSOR' has finished.
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exchanger</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							import java.util.concurrent.Exchanger
							import kotlin.concurrent.thread

							private val exchanger = Exchanger&lt;String&gt;()

							fun main() {
								thread(name = "A") { exchange(exchanger) }
								thread(name = "B") { exchange(exchanger) }
							}

							fun exchange(exchanger: Exchanger&lt;String&gt;) {
								try {
									val message = exchanger.exchange("Hello from ${Thread.currentThread().name}")
									println("Thread '${Thread.currentThread().name}' received message: $message")
								} catch (e: InterruptedException) {
									Thread.currentThread().interrupt()
									throw RuntimeException(e)
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Thread 'A' received message: Hello from B
							Thread 'B' received message: Hello from A
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>java.util.concurrent</h3>
				<div class="content">
					<p>
						<strong class="highlight">Concurrent Collections</strong><br />
						This includes thread-safe collection classes used in place of synchronized wrappers such as Hashtable or Collections.synchronizedMap(Map).
					</p>
					<p>
						<strong class="highlight">Locks</strong><br />
						More advanced and flexible locking mechanism compared to intrinsic locking.
					</p>
					<p>
						<strong class="highlight">Callable and Future</strong><br />
						Callable tasks are similar to Runnable tasks but they can return a result and are capable of throwing checked exceptions. Futures represent result of an asynchronous computation - a way to handle the results of callable tasks.
					</p>
					<p>
						<strong class="highlight">Executor Framework</strong><br />
						This is a higher-level replacement for working with threads directly. Executors are capable of managing a pool of threads, so we do not need to manually create new threads and run tasks in an asynchronous fashion.
					</p>
				</div>
			</section>
			<section>
				<h3>Future example</h3>
				<div class="content">
					<p>
						Again, <strong class="highlight">Future</strong> is one of the objects you may encounter when working with Java libraries in Kotlin.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							import java.util.concurrent.Executors
							import java.util.concurrent.Future

							fun main() {
								val messenger = Messenger()
								val message: Future&lt;String&gt; = messenger.receiveMessage()

								while (!message.isDone) {
									println("Waiting for message...")
									try {
										Thread.sleep(500)
									} catch (e: InterruptedException) {
										Thread.currentThread().interrupt()
										throw RuntimeException(e)
									}
								}

								try {
									println("Received message: ${message.get()}")
								} catch (e: Exception) {
									throw RuntimeException(e)
								}
							}

							class Messenger {
								private val executor = Executors.newSingleThreadExecutor()

								fun receiveMessage(): Future&lt;String&gt; {
									return executor.submit&lt;String&gt; {
										Thread.sleep(3000)
										"Hello from future!"
									}
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Waiting for message...
							Waiting for message...
							Waiting for message...
							Waiting for message...
							Waiting for message...
							Waiting for message...
							Received message: Hello from future!
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Coroutines</h2>
			</section>
			<section>
				<h3>Coroutines</h3>
				<div class="summary">
					Coroutines are light-weight alternative to threads, which are used for asynchronous programming.
				</div>
				<div class="content">
					<p>
						A coroutine is an instance of a suspendable computation.
						It allows for asynchronous code executions, like threads, but they are not bound to any particular thread.
						A coroutine may start executing in one thread, suspend its execution and resume in another one.

						This makes coroutines more efficient than threads - by design, they are non-blocking and reuse threads.
					</p>
					<p>
						Coroutines run in a context of a <strong class="highlight">CoroutineScope</strong>, which defines the lifecycle of the coroutine.
						When the scope is cancelled, all coroutines started in that scope are cancelled.
						CoroutineScope can only finish when all its inner coroutines are finished.
					</p>
					<blockquote>
						Coroutines are one of the main features of Kotlin, and while working with them is straightforward,
						I believe it is a topic for Kotlin Advanced course.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Coroutines Basics</h3>
				<div class="summary">
					There are several principles to work with coroutines.
				</div>
				<div class="content">
					<p>
						Let's explain with example:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() = runBlocking {

								launch {
									delay(1000)
									println("Kotlin Coroutines World!")
								}

								println("Hello")

							}
						</code>
					</pre>
					<ul>
						<li>
							<code class="inline">launch</code> - is a coroutine builder.
							It launches a new coroutine concurrently with the rest of the code, which continues to work independently.
						</li>
						<li>
							<code class="inline">delay</code> - suspends the coroutine for a specific time.
							Suspending a coroutine does not block the underlying thread, but allows other coroutines to run and use the underlying thread for their code.
						</li>
						<li>
							<code class="inline">runBlocking</code> - is also a coroutine builder that bridges the non-coroutine world of a regular fun main()
							and the code with coroutines inside of <code class="inline">runBlocking { ... }</code> curly braces.
						</li>
					</ul>
					<p>
						In this example, <code class="inline">Hello</code> is printed first, because the coroutine is suspended for 1 second.
					</p>
				</div>
			</section>
			<section>
				<h3>Coroutine Scope</h3>
				<div class="summary">
					Coroutine scope is a way to manage the lifecycle of coroutines.
				</div>
				<div class="content">
					<p>
						Coroutines follow a principle of <strong class="highlight">structured concurrency</strong>
						which means that new coroutines can only be launched in a specific coroutine scope which delimits the lifetime of the coroutine.
					</p>
					<ul>
						<li>It ensures that all coroutines are properly managed and not leaking outside of their scope.</li>
						<li>It also ensures that any errors in the code are properly reported and are never lost.</li>
					</ul>
					<p>
						Besides coroutine scopes provided by builders such as <code class="inline">runBlocking</code> and <code class="inline">launch</code>,
						you can also create your own coroutine scope using <code class="inline">coroutineScope</code> function.
					</p>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									fun main() = runBlocking {
										launch {
											task()
										}
										println("Hello")
									}
								</code>
							</pre>
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									suspend fun task() = coroutineScope {
										delay(1000)
										println("Kotlin Coroutines World!")
									}
								</code>
							</pre>
						</div>
					</div>
					<ul>
						<li>
							<code class="inline">coroutineScope</code> - a coroutine builder that creates a new coroutine scope.
							<ul>
								<li>It allows you to launch new coroutines in the scope of the current coroutine.</li>
								<li>An outer scope cannot complete until all its children coroutines complete.</li>
							</ul>

						</li>
						<li>
							<code class="inline">suspend</code> - a modifier that marks a function as a suspend function.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Suspendable Functions</h3>
				<div class="summary">
					<code class="inline">suspend</code> functions are the building blocks of coroutines.
				</div>
				<div class="content">
					<p>
						<code class="inline">suspend</code> functions ...
					</p>
					<ul>
						<li>
							can execute long-running operations without blocking the thread
						</li>
						<li>
							can be paused (suspended) and resumed at a later time, without blocking the underlying thread
						</li>
						<li>
							can only be called from other <code class="inline">suspend</code> functions or from coroutines scope.
						</li>
						<li>
							suspended function may resume their operation in a different thread
						</li>
					</ul>
					<p>
						Calling any suspend function from a non-suspend function, you will get a compilation error. If you need to cross the asynchronous to synchronous boundary, you can use <code class="inline">runBlocking</code> function.
					</p>
					<p>
						If you call multiple <code class="inline">suspend</code> functions like this, they will run in parallel.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() = runBlocking {

								val time = measureTimeMillis {
									val result1 = task1()
									val result2 = task2()
								}

								println("Milliseconds: $time")
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Suspendable Functions</h3>
				<div class="summary">
					Parallel execution of suspend functions.
				</div>
				<div class="content">
					<p>
						If you call multiple <code class="inline">suspend</code> functions, by default they will run in sequentionally.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() = runBlocking {

								val time = measureTimeMillis {
									val result1 = task1()
									val result2 = task2()
									println("$result1 $result2")
								}
								println("It took $time ms")
							}

							suspend fun task1(): String {
								delay(1000)
								return "Hello"
							}

							suspend fun task2(): String {
								delay(2000)
								return "Coroutines"
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Hello Coroutines
							It took 3037 ms
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Suspendable Functions</h3>
				<div class="summary">
					Parallel execution of suspend functions.
				</div>
				<div class="content">
					<p>
						To allow these functions to run in parallel, you can use <code class="inline">async</code> function with
						<code class="inline">await</code> function to get the result.
					</p>
					<pre>
					<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						fun main() = runBlocking {

							val time = measureTimeMillis {
								val result1 = async { task1() }
								val result2 = async { task2() }
								println("Result: ${result1.await() + result2.await()}")
							}

							println("It took $time ms")
						}

						suspend fun task1(): String {
							delay(1000)
							return "Hello"
						}

						suspend fun task2(): String {
							delay(2000)
							return "Coroutines"
						}
					</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Result: HelloCoroutines
							It took 2044 ms
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Coroutine Dispatchers</h3>
				<div class="summary">
					Coroutines are dispatched onto different threads using Dispatchers.
				</div>
				<div class="content">
					<p>
						The coroutine context includes a <strong class="highlight">CoroutineDispatcher</strong> that determines what thread or threads the corresponding coroutine uses for its execution. The coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, or let it run unconfined.
					</p>
					<p>
						There are some predefined dispatcher types available for specific tasks in Kotlin:
					</p>
					<ul>
						<li>
							<code class="inline">Dispatchers.Unconfined</code> - starts in the context of the current thread, but it can be resumed in a different thread.
						</li>
						<li>
							<code class="inline">Dispatchers.Default</code> - uses a shared background pool of threads.
						</li>
						<li>
							<code class="inline">Dispatchers.IO</code> - uses a shared pool of threads for I/O-bound tasks.
						</li>
					</ul>
					<p>
						There is also a <code class="inline">newSingleThreadContext</code> function that creates a dispatcher with a single thread.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							launch { // context of the parent, main runBlocking coroutine
								println("main runBlocking      : I'm working in thread ${Thread.currentThread().name}")
							}
							launch(Dispatchers.Unconfined) { // not confined -- will work with main thread
								println("Unconfined            : I'm working in thread ${Thread.currentThread().name}")
							}
							launch(Dispatchers.Default) { // will get dispatched to DefaultDispatcher
								println("Default               : I'm working in thread ${Thread.currentThread().name}")
							}
							launch(newSingleThreadContext("MyOwnThread")) { // will get its own new thread
								println("newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}")
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Unconfined            : I'm working in thread main
							Default               : I'm working in thread DefaultDispatcher-worker-1
							newSingleThreadContext: I'm working in thread MyOwnThread
							main runBlocking      : I'm working in thread main
						</code>
					</pre>
					<sub>
						This example is taken directly from
						<a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html#dispatchers-and-threads">Kotlin documentation</a>
					</sub>
				</div>
			</section>
			<section>
				<h3>Shared mutable state and concurrency</h3>
				<div class="content">
					<p>
						You can use the same principles for sharing state between coroutines as you would with threads.
					</p>
					<p>
						There are some additional mechanisms to handle shared mutable state in coroutines provided by Kotlin such as ...
					</p>
					<ul>
						<li>
							<strong class="highlight">Thread-safe data structures</strong> - such as <code class="inline">AtomicInteger</code>, <code class="inline">Semaphore</code>, etc.
						</li>
						<li>
							<strong class="highlight">Thread confinement</strong> - a way to ensure that a specific piece of code runs only in a specific thread.
						</li>
						<li>
							<strong class="highlight">Mutex</strong> - a mutual exclusion lock that allows only one coroutine to access a shared resource at a time.
						</li>
					</ul>
					<p>
						Let's create an example fo a function that launches 100 coroutines and each coroutine repeats an action 1000 times ...
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							suspend fun massiveRun(action: suspend () -> Unit) {
								val n = 100  // number of coroutines to launch
								val k = 1000 // times an action is repeated by each coroutine
								val time = measureTimeMillis {
									coroutineScope { // scope for coroutines
										repeat(n) {
											launch {
												repeat(k) { action() }
											}
										}
									}
								}
								println("Completed ${n * k} actions in $time ms")
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Shared mutable state and concurrency</h3>
				<div class="summary">
					Thread-safe data structures
				</div>
				<div class="content">
					<p>
						This isn't much different from working with threads.
						We control access to shared mutable state using thread-safe data structures such as <code class="inline">AtomicInteger</code>.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val counter = AtomicInteger()

							fun main() = runBlocking {
								withContext(Dispatchers.Default) {
									massiveRun {
										counter.incrementAndGet()
									}
								}
								println("Counter = $counter")
							}
						</code>
					</pre>
					<sub>
						This example is taken directly from
						<a href="https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#thread-safe-data-structures">Kotlin documentation</a>
					</sub>
				</div>
			</section>
			<section>
				<h3>Shared mutable state and concurrency</h3>
				<div class="summary">
					Thread confinement
				</div>
				<div class="content">
					<p>
						Thread confinement is an approach to the problem of shared mutable state where all access to
						the particular shared state is confined to a single thread.
					</p>
					<p>
						<strong>B) </strong> With each increment confine to a single-threaded context ...
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val counterContext = newSingleThreadContext("CounterContext")
							var counter = 0

							fun main() = runBlocking {
								withContext(Dispatchers.Default) {
									massiveRun {
										// confine each increment to a single-threaded context
										withContext(counterContext) {
											counter++
										}
									}
								}
								println("Counter = $counter")
							}
						</code>
					</pre>
					<p>
						<strong>B) </strong> With everything confined to a single-threaded context ...
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val counterContext = newSingleThreadContext("CounterContext")
							var counter = 0

							fun main() = runBlocking {
								// confine everything to a single-threaded context
								withContext(counterContext) {
									massiveRun {
										counter++
									}
								}
								println("Counter = $counter")
							}
						</code>
					</pre>
					<sub>
						This example is taken directly from
						<a href="https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#thread-confinement-fine-grained">Kotlin documentation</a>
					</sub>
				</div>
			</section>
			<section>
				<h3>Shared mutable state and concurrency</h3>
				<div class="summary">
					Mutex
				</div>
				<div class="content">
					<p>
						<code class="inline">Mutex</code> is a Kotlin mutual exclusion lock that allows only one coroutine to access a shared resource at a time.
					</p>
					<ul>
						<li>It is a suspending function, so it does not block the underlying thread.</li>
						<li>It has a <code class="inline">lock</code> and <code class="inline">unlock</code> functions to delimit a critical section.</li>
						<li>You can also use <code class="inline">withLock</code> extension function to represent <code class="inline">lock(); try { ... } finally { unlock() }</code> pattern.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val mutex = Mutex()
							var counter = 0

							fun main() = runBlocking {
								withContext(Dispatchers.Default) {
									massiveRun {
										// protect each increment with lock
										mutex.withLock {
											counter++
										}
									}
								}
								println("Counter = $counter")
							}
						</code>
					</pre>
					<sub>
						This example is taken directly from
						<a href="https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#mutual-exclusion">Kotlin documentation</a>
					</sub>
				</div>
			</section>
			<section>
				<h3>Coroutine and Channels</h3>
				<div class="summary">
					Channels are a way to communicate between coroutines.
				</div>
				<div class="content">
					<p>
						Kotlin's coroutine channels are a mechanism for communication between coroutines.
						They allow multiple coroutines to send and receive data, much like blocking queues,
						but in a non-blocking way.
						Channels are especially useful in scenarios where coroutines need to share or process streams of data concurrently.
					</p>
					<p>
						<strong class="highlight">Basic channel operations</strong>
					</p>
					<ul>
						<li>
							<code class="inline">send(value)</code>: Sends a value to the channel. This suspends the sender if the channel is full.
						</li>
						<li>
							<code class="inline">receive()</code>: Receives a value from the channel. This suspends the receiver if the channel is empty.
						</li>
						<li>
							<code class="inline">close()</code>: Closes the channel, signaling that no more values will be sent.
						</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() = runBlocking {
								val channel = Channel&lt;Int&gt;() // Create a channel of type Int

								// Launch a coroutine to send values
								launch {
									for (i in 1..5) {
										channel.send(i)  // Send values to the channel
										println("Sent: $i")
									}
									channel.close()  // Close the channel after sending all values
								}

								// Receive values from the channel
								for (value in channel) {
									println("Received: $value")
								}
							}
						</code>
					</pre>
					<p>
						There, the sender coroutine sends values to the channel,
						and the receiver iterates over the channel to receive values until the channel is closed.
					</p>
					<p>
						Once a channel is closed, no more values can be sent, and the for loop over the channel will terminate gracefully.
					</p>
				</div>
			</section>
			<section>
				<h3>Buffered Channels</h3>
				<div class="content">
					<p>
						By default, channels are unbuffered, meaning the sender and receiver must synchronize before data is passed.
						Buffered channels allow the sender to send multiple items before the receiver has to process them.

					</p>
				</div>
				<pre>
					<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						val channel = Channel&lt;Int&gt;(capacity = 3) // A buffered channel with capacity 3
					</code>
				</pre>
				<pre>
					<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						fun main() = runBlocking {
							val channel = Channel&lt;Int&gt;(3) // Buffer size is 3

							launch {
								repeat(5) {
									channel.send(it)
									println("Sent: $it")
								}
								channel.close()
							}

							for (value in channel) {
								println("Received: $value")
							}
						}
					</code>
				</pre>
			</section>
			<section>
				<h3>Conflated Channels</h3>
				<div class="content">
					<p>
						Conflated channels retain only the latest sent value and discard previous ones if not yet received.
						This is useful for scenarios like UI updates, where only the latest state matters.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val conflatedChannel = Channel&lt;Int&gt;(Channel.CONFLATED)
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() = runBlocking {
								val channel = Channel&lt;Int&gt;(Channel.CONFLATED)

								launch {
									channel.send(1)
									channel.send(2)  // The first value is overwritten before it's received
									channel.send(3)
									channel.close()
								}

								println("Received: ${channel.receive()}")  // Only the latest value (3) is received
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>
					Use Cases of Channels
				</h3>
				<div class="content">
					<ul>
						<li>
							<h4>Producer-Consumer</h4>
							<p>
								Channels are often used to implement pipelines, where data flows through multiple stages, each represented by a coroutine.
							</p>
						</li>
						<li>
							<h4>Streaming Data</h4>
							<p>
								Channels are useful for processing real-time data feeds and event streams.
							</p>
						</li>
						<li>
							<h4>UI Updates</h4>
							<p>
								Channels can be used to propagate the latest state to UI components.
							</p>
						</li>
						<li>
							<h4>Work Distribution</h4>
							<p>
								Channels can be used to split tasks between multiple workers in a coroutine system.
							</p>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Coroutine Cancellation, Timeouts and Exceptions</h3>
				<div class="summary">
					Coroutine Cancellation
				</div>
				<div class="content">
					<p>Handling cancellation, timeouts, and exceptions properly is crucial for building reliable coroutine-based applications. Let’s break down how Kotlin coroutines handle each scenario.</p>
					<p>
						Coroutines in Kotlin are cooperative, meaning they need to actively check for cancellation and respond appropriately.
					</p>
					<p>
						Coroutines can be cancelled by calling the <code class="inline">cancel()</code> function on a coroutine’s Job.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() = runBlocking {
								try {
									repeat(1000) { i ->
										println("Job: $i")
										delay(500)  // Suspending function that checks for cancellation
									}
								} finally {
									println("Cleanup")
								}

								delay(2000)  // Let the coroutine run for 2 seconds
								println("Cancelling the job")
								job.cancel()  // Cancel the coroutine
								job.join()    // Wait for the coroutine to complete
								println("Job cancelled")
							}
						</code>
					</pre>
					<p>
						The coroutine checks for cancellation during the delay(500) call.
						Without cooperative functions (e.g., delay, yield), the coroutine won’t be cancelled unless you manually handle it.
					</p>
					<p>
						When a coroutine is cancelled, any cleanup operations (e.g., closing resources) should be performed in the finally block.
					</p>
				</div>
			</section>
			<section>
				<h3>Coroutine Cancellation, Timeouts and Exceptions</h3>
				<div class="summary">
					Timeouts
				</div>
				<div class="content">
					<p>
						<code class="inline">withTimeout</code> allows you to automatically cancel a coroutine if it takes longer than a specified time.
					</p>
					<p>
						<code class="inline">TimeoutCancellationException</code> is thrown if the timeout is reached.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() = runBlocking {
								try {
									withTimeout(1500) {  // Timeout after 1.5 seconds
										repeat(1000) { i ->
											println("Task: $i")
											delay(500)
										}
									}
								} catch (e: TimeoutCancellationException) {
									println("Coroutine timed out: ${e.message}")
								}
							}
						</code>
					</pre>
					<p>
						If you want to handle timeouts without throwing an exception, use <code class="inline">withTimeoutOrNull</code> , which returns null if the timeout is exceeded.
					</p>
				</div>
			</section>
			<section>
				<h3>Coroutine Cancellation, Timeouts and Exceptions</h3>
				<div class="summary">
					Handling Exceptions in Coroutines
				</div>
				<div class="content">
					<p>
						Exceptions in coroutines are handled differently depending on the coroutine builder (launch, async, etc.):
					</p>
					<ul>
						<li><code class="inline">launch</code>: Exceptions are propagated to the parent and cause the coroutine to cancel.</li>
						<li><code class="inline">async</code>: Exceptions are not thrown immediately but are propagated when calling  <code class="inline">await()</code>.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Coroutine Cancellation, Timeouts and Exceptions</h3>
				<div class="summary">
					Supervisor Jobs and Exception Propagation
				</div>
				<div class="content">
					<p>
						<strong class="inline">SupervisorJob</strong> allows you to isolate the failure of one child coroutine from affecting other coroutines in the same scope.
						In a <strong class="inline">SupervisorJob</strong>, exceptions from one coroutine do not cancel sibling coroutines.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() = runBlocking {
								val supervisor = SupervisorJob()

								val scope = CoroutineScope(coroutineContext + supervisor)

								val job1 = scope.launch {
									println("Job 1 started")
									delay(1000)
									throw Exception("Job 1 failed")
								}

								val job2 = scope.launch {
									println("Job 2 started")
									delay(2000)
									println("Job 2 completed")
								}

								job1.join()
								job2.join()  // Job 2 is not affected by Job 1's failure
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							Job 1 started
							Job 2 started
							Exception in thread "main" java.lang.Exception: Job 1 failed
								at MainKt$main$1$job1$1.invokeSuspend(Main.kt:11)
								at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
								...
								at MainKt.main(Main.kt:3)
								at MainKt.main(Main.kt)
								Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine{Cancelling}@2aafb23c, BlockingEventLoop@2b80d80f]
							Job 2 completed
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Coroutine Best Practices</h3>
				<div class="content">
					<ol>
						<li>Always use <code class="inline">runBlocking</code> in a limited scope (typically only in main functions or tests).</li>
						<li>Prefer <code class="inline">CoroutineScope</code> to manage coroutines in more complex applications.</li>
						<li>Use <code class="inline">withContext(Dispatchers.IO)</code> for blocking I/O operations to prevent UI blocking.</li>
						<li>Use structured concurrency principles to manage coroutine lifecycles (avoid orphaned coroutines).</li>
					</ol>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Next Lesson</h2>
				<em>↓</em>
			</section>
			<section>
				<h3>Next Lesson</h3>
				<div class="content content-center">
					Validation, Exceptions and Error Handling
				</div>
			</section>
		</section>
	</div>
</div>

<script src="./src/dist/reveal.js"></script>
<script src="./src/plugin/notes/notes.js"></script>
<script src="./src/plugin/markdown/markdown.js"></script>
<script src="./src/plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
