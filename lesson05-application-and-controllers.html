<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="./src/dist/reset.css">
	<link rel="stylesheet" href="./src/dist/reveal.css">
	<link rel="stylesheet" href="./src/dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/vs.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-gradient="var(--kotlin-gradient)">
			<i>Week 2 | Lesson 4</i>
			<h1>Application Programming Interface</h1>
			<em>REST API</em><br />
<!--			<em>Reflection</em>-->
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Backend Services</h2>
			</section>
			<section>
				<h3>Backend Services</h3>
<!--				<div class="summary">-->
<!--					Backend services usually handle business logic and data storage and provide APIs for frontend applications to interact with.-->
<!--				</div>-->
				<div class="content">
					<p>
						Backend services usually handle business logic and data storage and provide APIs for other
						applications to interact with.
					</p>
					<p>
						They implement a server-client architecture,
						where the server is responsible for processing requests and the client is responsible for presenting the data to the user.
					</p>
					<p>
						Backend services can also be consumed by other backend services.
					</p>
					<p>
						Sometimes, they may also provide a user interface, but this is not their primary purpose and
						is more of a legacy approach.
					</p>
					<p>
						The most common API for backend services is REST API, or GraphQL.
						Both of these APIs are based on HTTP protocol and allow clients to interact with the server using standard HTTP methods.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>What is API</h2>
			</section>
			<section>
				<h3>What is API</h3>
				<div class="summary">
					API stands for <strong>Application Programming Interface</strong>.
				</div>
				<div class="content">
					<ul>
						<li>
							It is a set of rules and protocols that allow different software applications to communicate with each other.
						</li>
						<li>
							In contrast to user interface, API is meant for program to program or computer to computer communication.
						</li>
						<li>
							There are many forms of APIs, such as web APIs, library APIs, and operating system APIs.
							Some APIs are specific to a particular programming language, some are specific to a particular application.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Design of API</h3>
				<div class="content">
					<blockquote>
						When you think about designing an interface, you first need to think about the problem you are trying to solve with it.
						Consider how the API will be used, and design it in a way that is convenient for the users of the API.
					</blockquote>
					<p>
						This is why in this course, we will start by designing and interface (API) and only then we will implement the service and data model behind it.
					</p>
					<p>
						If we did it the other way around, we would be tempted to design the service and data model in a way that is convenient for us, the developers, and not in a way that is convenient for the users of the API.
					</p>
				</div>

			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>What is REST</h2>
			</section>
			<section>
				<h3>What is REST</h3>
				<div class="summary">
					REST stands for <string>Representational State Transfer</string>.
				</div>
				<div class="content">
					<blockquote>
						It is an architectural style for designing networked applications.
						Systems that follow REST principles are often called RESTful systems.
						Characteristics of RESTful systems include <strong>statelessness</strong>,
						<strong>client-server architecture</strong>, and a <strong>uniform interface</strong>.
					</blockquote>
					<ul>
						<li>
							<strong class="highlight">Statelessness</strong><br />
							Each request from a client to a server must contain all of the information
							necessary process the request, without relying on any server state being held between requests.
						</li>
						<li>
							<strong class="highlight">Client-server architecture</strong><br />
							The client and server are separate and independent of each other, only communicating by well-defined requests and responses.
							This allows each to be developed and scaled independently.
							<br />
							<br />
							In real applications, client is usually responsible for the user interactions and the server is responsible for the data storage and processing.
						</li>
						<li>
							<strong class="highlight">Uniform interface</strong><br />
							The API should be designed in a way that is consistent, predictable,
							handles errors gracefully, is platform-agnostic, and is easy to understand and use.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API</h3>
				<div class="summary">
					Communication through REST API is done using standard HTTP methods,
					such as <strong>GET</strong>, <strong>POST</strong>, <strong>PUT</strong>, and <strong>DELETE</strong>.
				</div>
				<div class="content">
					<p>
						REST communication is <strong>request-response</strong> protocol,
						which means that the client sends a request to the server, and the server sends a response back to the client.
					</p>
					<p>
						Each request is sent to a unique URI (Uniform Resource Identifier),
						which represents a <strong>resource</strong> on the server.
					</p>
					<p>
						The server processes the request and sends back a response, which may include data, status,
						and other information, usually in JSON or XML format.
					</p>
				</div>
			</section>
			<section>
				<h3>Request</h3>
				<div class="content">
					<ul>
						<li>
							<strong>HTTP Method</strong><br />
							<em>Defines the type of action to be performed on the resource.</em>
							<br />
							<code class="inline">
								GET /accounts
							</code>
						</li>
						<li>
							<strong>URI</strong><br />
							<em>
								Identifies a unique <strong>resource</strong> on the server.
								It is usually composed of <strong>path</strong> and optionally <strong>query parameters</strong>.
							</em>
							<br />
							<code class="inline">
								GET /accounts/123/users?limit=10&search=joe
							</code>
						</li>
						<li>
							<strong>Headers</strong><br />
							<em>
								These can be used to send additional data with the request, such as the content type or an authorization token.
							</em>
							<br />
							<code class="inline">Content-Type: application/json</code><br />
							<code class="inline">Authorization: Bearer some-token-value</code>
						</li>
						<li>
							<strong>Body</strong><br />
							<em>
								Body is usually sent only with <strong>POST</strong>, <strong>PUT</strong> and <strong>PATCH</strong> requests.
								In most cases, this will be formatted as JSON or XML.
							</em>
							<br />
							<code class="inline">
								{ "username": "testUser", "password" : "123456" }
							</code>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Response</h3>
				<div class="content">
					<ul>
						<li>
							<strong>HTTP Status Code</strong><br />
							A numerical code that indicates the success or failure of the request.
							There is a convention for what status code should be used in what situation.
						</li>
						<li>
							<strong>Headers</strong><br />
							As in the request, headers in the response can be used to pass additional information. This might include the content type of the response, or a Set-Cookie header to store information in the client's browser.
						</li>
						<li>
							<strong>Body</strong><br />
							This contains the actual data being returned from the server.
							This will usually be in JSON or XML format, or could also be plain text.
							<br />
							<code class="inline">
								{ "id": 1, "username": "testUser", "email": "testUser@example.com" }
							</code>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Methods</h3>
				<div class="summary">
					In theory, you can use all methods of HTTP protocol to communicate with REST API.
				</div>
				<div class="content">
					<p>
						In practice, you will mostly use ...
					</p>
					<ul>
						<li>
							<strong>GET</strong><br />
							Used to retrieve data from the server. It should never change the state of the server.
						</li>
						<li>
							<strong>POST</strong><br />
							Used to send data to the server to create a new resource.
						</li>
						<li>
							<strong>PUT</strong><br />
							<em>
								Used to send data to the server to update an existing resource.
								Changes should be idempotent, meaning that if you send the same request multiple times,
								the result should be the same as if you sent it once.
								In other words, PUT should be used to update the resource as a whole.
							</em>
						</li>
						<li>
							<strong>DELETE</strong><br />
							Used to delete a resource from the server.
						</li>
						<li>
							<strong>PATCH</strong><br />
							Used to partially update a resource on the server.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Paths</h3>
				<div class="summary">
					URI is the path to the resource on the server.
				</div>
				<div class="content">
					<p>
						You can use <strong>path parameters</strong> to specify a particular resource,
						and <strong>query parameters</strong> to, for example, filter or paginate the results.
					</p>
					<p>
						Here is the conventional structure of the resource:
						<br />
						<br />
						<code style="color: steelblue">/resources/</code>
						<code style="color: magenta">{path-parameter}</code>
						<code style="color: steelblue">/sub-resource</code>
						<code style="color: red">?</code>
						<code style="color: green">param1=value</code>
						<code style="color: orange">&</code>
						<code style="color: green">param2=value</code>
					</p>
					<ul>
						<li><span style="color: steelblue">resource path</span></li>
						<li><span style="color: magenta">path parameter</span></li>
						<li><span style="color: red">path and query parameter separator</span> </li>
						<li><span style="color: orange">query parameter separator</span></li>
						<li><span style="color: green">query parameters </span> and their values</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Headers</h3>
				<div class="summary">
					Headers are used to pass additional information with the request or response.
				</div>
				<div class="content">
					<p>
						Headers are usually conventional, meaning that there are some standard headers that are used in most APIs.
						REST services can also define their own custom headers.
					</p>
					<p>Some of the most common conventional headers are:</p>
					<ul>
						<li>
							<strong>Content-Type</strong><br />
							Used to specify the format of the body of the request.<br />
							<code class="inline">Content-Type: application/json</code>
						</li>
						<li>
							<strong>Accept</strong><br />
							Used to specify the format of the response.<br />
							<code class="inline">Accept: application/json</code>
						</li>
						<li>
							<strong>Authorization</strong><br />
							Used to pass an authorization token with the request.<br />
							<code class="inline">Authorization: Bearer some-token-value</code>
						</li>
						<li>
							<strong>X-Api-Key</strong><br />
							Used to pass an API key with the request.<br />
							<code class="inline">X-Api-Key: some-api-key-value</code>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Body</h3>
				<div class="summary">
					Body is usually sent only with <strong>POST</strong>, <strong>PUT</strong> and <strong>PATCH</strong> requests.
				</div>
				<div class="content">
					<p>
						Body is almost exclusively custom, meaning that it is up to the service to define what the body of the request or response should look like.
					</p>
					<p>
						Most common formats for the body are JSON and XML.
					</p>
					<p>
						JSON:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs json">
							{
								"id": 1234,
								"firstName": "Monika",
								"lastname": "Protivova",
								"email": "monika.protivova@gmail.com",
								"isAdmin": true
							}
						</code>
					</pre>
					<p>
						XML:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs xml">
							&lt;user&gt;
								&lt;id&gt;1234&lt;/id&gt;
								&lt;firstName&gt;Monika&lt;/firstName&gt;
								&lt;lastname&gt;Protivova&lt;/lastname&gt;
								&lt;email&gt;monika.protivova@gmail.com&lt;/email&gt;
								&lt;isAdmin&gt;true&lt;/isAdmin&gt;
							&lt;/user&gt;
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Status Codes</h3>
				<div class="summary">
					HTTPS status codes are used to indicate the success or failure of the request.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<ul>
								<li>
									<strong>1xx</strong><br />
									Informational responses. The request was received, continuing process.
									<ul>
										<li>100 - Continue</li>
										<li>101 - Switching Protocols</li>
									</ul>
								</li>
								<li>
									<strong>2xx</strong><br />
									Success. The action was successfully received, understood, and accepted.
									<ul>
										<li>200 - OK</li>
										<li>201 - Created</li>
									</ul>
								</li>
								<li>
									<strong>3xx</strong><br />
									Redirection. Further action must be taken in order to complete the request.
									<ul>
										<li>301 - Moved Permanently</li>
									</ul>
								</li>
							</ul>
						</div>
						<div class="column">
							<ul>
								<li>
									<strong>4xx</strong><br />
									Client Error. The request contains bad syntax or cannot be fulfilled.
									<ul>
										<li>400 - Bad Request</li>
										<li>401 - Unauthorized</li>
										<li>403 - Forbidden</li>
										<li>404 - Not Found</li>
									</ul>
								</li>
								<li>
									<strong>5xx</strong><br />
									Server Error. The server failed to fulfill an apparently valid request.
									<ul>
										<li>500 - Internal Server Error</li>
									</ul>
								</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Naming conventions</h4>
					<ul>
						<li>Paths should be nouns and should be plural.</li>
						<li>Paths should represent hierarchical relationships.</li>
						<li>Paths should preferably be lowercase, and not case-sensitive.</li>
						<li>Query parameters should be named in consistent matter, either using
							<ul>
								<li>camelCase</li>
								<li>snake_case</li>
								<li>kebab-case</li>
								<li> ... but not combining them</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Versioning</h4>
					<ul>
						<li>Once you publish a (public) API, you may not be able to control who uses it.</li>
						<li>API versioning is thus important to ensure that any changes are backward compatible.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Request and response format</h4>
					<ul>
						<li>API should return data in a consistent format, such as JSON or XML.</li>
						<li>Naming conventions should be consistent, for example, use <code class="inline">camelCase</code> or <code class="inline">snake_case</code> consistently throughout the API.</li>
						<li>For services written in Java, it is more nature to use <code class="inline">camelCase</code>, because it matches class field naming conventions.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Response codes and error handling</h4>
					<ul>
						<li>Each method should respond with appropriate status code.</li>
						<li>For example:
							<ul>
								<li>successful requests that do not modify resource should be either 200 or 204</li>
								<li>successful requests that create a new resource should be 201</li>
								<li>requests that fail due to user error should return 4xx</li>
								<li>requests that fail due to user input error should fail with 400</li>
								<li>requests tha fail due to authentication error should fail with 401</li>
								<li>requests that fail due to authorization error should fail with 403</li>
								<li>requests that fail due to resource not found should fail with 404</li>
								<li>requests that fail due to server error should return 5xx</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Overall consistency</h4>
					<ul>
						<li>API should be consistent in its design and behavior.</li>
						<li>For example, if POST method for one resource returns the newly created object, then POST method for another resource should also return the newly created object.</li>
					</ul>
				</div>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>GraphQL</h2>
			</section>
			<section>
				<h3>GraphQL</h3>
				<div class="summary">
					GraphQL is an alternative to REST API, which allows clients to request only the data they need.
				</div>
				<div class="content">
					<p>
						GraphQL is a query language for APIs and a runtime for executing those queries with your existing data.
						It was developed by Facebook in 2012 and released as an open-source project in 2015.
					</p>
					<p>
						It allows clients to request only the data they need, and nothing more.
						This makes it more efficient than REST API, which often returns more data than the client needs.
					</p>
					<p>
						GraphQL is based on a single endpoint, which handles all requests.
						The client sends a query to the server, and the server responds with the requested data.
					</p>
				</div>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>WebSockets</h2>
				<em>using Ktor</em>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Application</h2>
				<em>using Ktor</em>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Application Routing</h2>
			</section>
			<section>
				<h3>Application Routing</h3>
				<div class="summary">
					TODO
				</div>
				<div class="content">
					TODO
				</div>
			</section>
		</section>

<!--		<section>-->
<!--			<section data-background-gradient="var(&#45;&#45;kotlin-gradient)">-->
<!--				<h2>Reflection</h2>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h3>Reflection</h3>-->
<!--				<div class="summary">-->
<!--					Reflection allows us to inspect and modify runtime behavior of classes, interfaces, fields, and methods at runtime, without knowing their name at compile time.-->
<!--				</div>-->
<!--				<div class="content">-->
<!--					<p>-->
<!--						Reflection is part of the Kotlin API, and is defined in the <code class="inline">kotlin.reflect</code> package.-->
<!--					</p>-->
<!--					<p>-->
<!--						Reflection is used by many frameworks, such as Spring, Jackson, Hibernate, and JUnit.-->
<!--					</p>-->
<!--					<p>-->
<!--						<strong>Reflection allows us to:</strong>-->
<!--					<ul>-->
<!--						<li>Inspect classes</li>-->
<!--						<li>Inspect constructors</li>-->
<!--						<li>Inspect methods</li>-->
<!--						<li>Inspect fields</li>-->
<!--						<li>Instantiate objects dynamically</li>-->
<!--						<li>Invoke methods</li>-->
<!--						<li>Get or set field value</li>-->
<!--						<li>Change field value</li>-->
<!--					</ul>-->
<!--					</p>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h3>Reflection</h3>-->
<!--				<div class="content">-->
<!--					Given class ...-->
<!--					<pre>-->
<!--						<code data-trim data-noescape data-line-numbers class="hljs kotlin">-->
<!--							package lesson10-->

<!--							class Employee(-->
<!--								val id: Long,-->
<!--								private var firstName: String,-->
<!--								private var lastName: String,-->
<!--								private var position: String-->
<!--							) {-->

<!--								fun getEmployee(): String = "$firstName $lastName: $position"-->

<!--								fun updateEmployee(firstName: String, lastName: String, position: String) {-->
<!--									this.firstName = firstName-->
<!--									this.lastName = lastName-->
<!--									this.position = position-->
<!--								}-->
<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h3>Reflection</h3>-->
<!--				<div class="content">-->
<!--					Inspection of classes, constructors, methods and fields.-->
<!--					<pre>-->
<!--						<code data-trim data-noescape data-line-numbers class="hljs kotlin">-->
<!--							package lesson10;-->

<!--							fun main() {-->
<!--								val obj = Employee(-->
<!--									id = 123,-->
<!--									firstName = "Monika",-->
<!--									lastName = "Protivova",-->
<!--									position = "Kotlin Developer"-->
<!--								)-->

<!--								val cls = obj.javaClass-->

<!--								// Inspect class-->
<!--								println("Class: ")-->
<!--								println(" Name = ${cls.name}")-->
<!--								println(" Simple Name = ${cls.simpleName}")-->
<!--								println(" Package = ${cls.`package`}")-->
<!--								println(" Superclass = ${cls.superclass}")-->
<!--								println(" Interfaces = ${cls.interfaces.contentToString()}")-->

<!--								// Inspect constructors-->
<!--								val constructors = cls.constructors-->
<!--								println("Constructors: ")-->
<!--								for (constructor in constructors) {-->
<!--									println(" Parameters = ${constructor.parameterTypes.contentToString()}")-->
<!--								}-->

<!--								// Inspect methods-->
<!--								val methods = cls.methods-->
<!--								println("Methods: ")-->
<!--								for (method in methods) {-->
<!--									println(" Method = ${method.name}")-->
<!--									println(" Parameters = ${method.parameterTypes.contentToString()}")-->
<!--								}-->

<!--								// Inspect fields-->
<!--								val fields = obj.javaClass.declaredFields-->
<!--								println("Fields: ")-->
<!--								for (field in fields) {-->
<!--									println(" Field = ${field.name}")-->
<!--									println(" Type = ${field.annotatedType}")-->
<!--								}-->
<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h3>Reflection</h3>-->
<!--				<div class="content">-->
<!--					Instantiation, dynamic invocation of methods and fields, and changing field values.-->
<!--					<pre>-->
<!--						<code data-trim data-noescape data-line-numbers class="hljs kotlin">-->
<!--							package lesson10;-->

<!--							import java.time.LocalDate-->

<!--							fun main() {-->
<!--								try {-->
<!--									// get class by fully qualified name-->
<!--									val cls = Class.forName("lesson10.Employee")-->

<!--									// create instance-->
<!--									val instance = cls-->
<!--										.getDeclaredConstructor(Long::class.java, String::class.java, String::class.java, String::class.java)-->
<!--										.newInstance(123, "Monika", "Protivova", "Developer")-->

<!--									// get method-->
<!--									val getterMethod = cls.getDeclaredMethod("getEmployee")-->

<!--									// invoke the method on existing instance-->
<!--									val getterValue = getterMethod.invoke(instance)-->

<!--									// should print Java-->
<!--									println(getterValue)-->

<!--									val setterMethod = cls.getDeclaredMethod("updateEmployee", String::class.java, String::class.java, String::class.java)-->
<!--									val noReturnValue = setterMethod.invoke(instance, "Monika", "Protivova", "Kotlin Developer")-->

<!--									// should print null-->
<!--									println(noReturnValue)-->

<!--									// should print Python-->
<!--									println(getterMethod.invoke(instance))-->

<!--								} catch (e: Exception) {-->
<!--									// reflection may throw multiple types of exceptions-->
<!--									println("Error: ${e.message}")-->
<!--								}-->
<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h4>Reflection use cases</h4>-->
<!--				<div class="summary">-->
<!--					Reflection is often used by frameworks and libraries to provide functionality that would be difficult to achieve otherwise,-->
<!--					such as runtime configuration, serialization, and deserialization, type analysis, object instantiation, and method invocation.-->
<!--				</div>-->
<!--				<div class="content">-->
<!--					<div>-->
<!--						<h4>Frameworks</h4>-->
<!--						<p>-->
<!--							Java/Kotlin frameworks use reflection to analyze and manipulate the classes, interfaces, constructors, methods, and fields that they work with.-->
<!--							For instance, Spring Framework uses it to create classes via IoC, Hibernate uses reflection API to fetch data and populate your entity objects.-->
<!--						</p>-->
<!--					</div>-->
<!--					<br />-->
<!--					<div>-->
<!--						<h4>Testing</h4>-->
<!--						<p>-->
<!--							Tools like JUnit and Mockito use the reflection to observe class, field, and method size, and also to call methods while doing the testing.-->
<!--						</p>-->
<!--					</div>-->
<!--					<br />-->
<!--					<div>-->
<!--						<h4>Serialization & Deserialization</h4>-->
<!--						<p>-->
<!--							Reflection is often used to convert (text) data, such as JSON, to an equivalent Java objects and vice versa.-->
<!--						</p>-->
<!--					</div>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h4>Reflection pitfalls</h4>-->
<!--				<div class="summary">-->
<!--					Despite its usefulness, it is not recommended to use reflection where not necessary because of the following reasons.-->
<!--				</div>-->
<!--				<div class="content" style="font-size: 70%">-->
<!--					<div>-->
<!--						<h4>Performance Overhead</h4>-->
<!--						<p>-->
<!--							Reflection operations have performance overhead because it involves type inference, and often disables certain JVM optimizations.-->
<!--							Reflective code is therefore generally slower than the normal code, and should be avoided in parst of the code that are called frequently,-->
<!--							or in performance-critical applications.-->
<!--						</p>-->
<!--					</div>-->
<!--					<div>-->
<!--						<h4>Exposure of Internals</h4>-->
<!--						<p>-->
<!--							Reflections allows access to restricted parts of the code, such as private methods and fields.-->
<!--							By doing this, it breaks the encapsulation and exposes the internals of the class in a way it was not designed to be used.-->
<!--						</p>-->
<!--					</div>-->
<!--					<div>-->
<!--						<h4>Lack of Compile-Time Safety</h4>-->
<!--						<p>-->
<!--							Reflection bypasses the compile-time type checks, and therefore may result in runtime exceptions.-->
<!--						</p>-->
<!--					</div>-->
<!--					<div>-->
<!--						<h4>Decreased Maintainability of Code</h4>-->
<!--						<p>-->
<!--							Reflection makes the code less readable and maintainable, by making it more difficult to understand.-->
<!--							It also makes the code more error-prone, because the compiler cannot detect errors in the reflective code.-->
<!--						</p>-->
<!--						<p>-->
<!--							Additionally, it makes a lot of development tools, such as IDEs, less useful, because they cannot analyze the reflective code.-->
<!--						</p>-->
<!--					</div>-->
<!--					<div>-->
<!--						<h4>Security Concerns</h4>-->
<!--						<p>-->
<!--							Reflection can access and manipulate private fields and methods, which can be a security concern.-->
<!--						</p>-->
<!--					</div>-->
<!--				</div>-->
<!--			</section>-->
<!--		</section>-->

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Arrays</h2>
			</section>
			<section>
				<h3>Arrays</h3>
				<div class="summary">
					Array is a <span class="highlight">fixed-size</span> sequential collection of elements of the same type.
				</div>
				<div class="content">
					<div>
						<h4 class="highlight">Declaration and Initialization</h4>
						<ul>
							<li>Arrays can be declared using the <code class="inline">arrayOf&lt;Type&gt;()</code> function.</li>
							<li>Arrays are fixed-size, meaning their size cannot be changed once created.</li>
						</ul>
					</div>
					<br />
					<div>
						<h4 class="highlight">Type-Safety</h4>
						<ul>
							<li>
								Arrays in Kotlin are type-safe - they can only hold elements of the specified type (and its subtypes).
								<br />
								<sub>
									If array contains elements of different types, the type of the array is inferred to be the least common supertype of the elements,
									<br />
									or <code class="inline">Any</code> in case of no common supertype.
								</sub>
							</li>
							<li>The type declaration can be omitted if the type of the array can be inferred from the elements passed to the function.</li>
						</ul>
					</div>
					<br />
					<div>
						<h4 class="highlight">Access and Modification</h4>
						<ul>
							<li>
								Elements can be accessed or modified using their index and <code class="inline">[]</code> operator. Arrays are zero-based
								<br />
								<sub>For example <code class="inline">array[0]</code> will access first element.
								</sub>
							</li>
							<li>Modifying an element using an index that is out of bounds will throw an <code class="inline">ArrayIndexOutOfBoundsException</code>.</li>
							<li>Arrays can be iterated using loops.</li>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<h3>Array Declaration and Initialization</h3>
				<div class="content">
					<ul>
						<li>
							Arrays can be declared using the <code class="inline">arrayOf&lt;Type&gt;()</code> function.
							<br />
							<sub>Type declaration can be omitted if the type of the array can be inferred from the elements passed to the <code class="inline">arrayOf()</code> function.</sub>
						</li>
						<li>
							Arrays in Kotlin are <strong class="highlight">type-safe</strong> - they can only hold elements of the specified type.
							<br />
							<sub>
								If array contains elements of different types, the type of the array is inferred to be the least common supertype of the elements,
								<br />
								or <code class="inline">Any</code> in case of no common supertype.
							</sub>
						</li>
						<li>Arrays are <strong class="highlight">fixed-size</strong>, meaning their size cannot be changed once created.</li>
					</ul>
					<pre data-trim>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							// Declaring an array of integers
							val numbers = arrayOf(1, 2, 3, 4, 5)

							// Declaring an array of strings
							val cities = arrayOf("Bangkok", "Beijing", "Tokyo", "London", "Paris")

							// Declaring an array of mixed types
							val mixed = arrayOf(1, "Bangkok", 3.14, 'A', true)

							val empty = emptyArray&lt;String&gt;() // size 0

							val arrayOfNulls = arrayOfNulls&lt;String&gt;(5) // size 5, all elements are null
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Array Access and Modification</h3>
				<div class="content">
					<ul>
						<li>
							Elements can be accessed or modified using their index and <code class="inline">[]</code> operator.
							Arrays are <strong class="highlight">zero-based</strong>.
							<br />
							<sub>For example <code class="inline">array[0]</code> will access first element.
							</sub>
						</li>
						<li>Modifying an element using an index that is out of bounds will throw an <code class="inline">ArrayIndexOutOfBoundsException</code>.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val array = arrayOf(1, 2, 3, 4, 5)

							// updating an element on index 4 (5th element)
							array[4] = 42

							// accessing an element on index 4 (5th element)
							println(array[4])

							// accessing an element on index 5 (6th element) - will throw ArrayIndexOutOfBoundsException
							try {
								println(array[5])
							} catch (e: ArrayIndexOutOfBoundsException) {
								println(e.message)
							}
						</code>
					</pre>
					You can get size of the array using <code class="inline">size</code> property.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							println(array.size) // prints 5
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Array Operations</h3>
				<div class="summary">
					Given and array, some of the common operations on arrays include ...
				</div>
				<div class="content">
					<div>
						Iterating an array using a <code class="inline">for</code> loop or <code class="inline">forEach</code> function.
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								for (element in array) {
									println(element)
								}
							</code>
						</pre>
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								array.forEach { println(it) }
							</code>
						</pre>
						Filtering an array
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								val filtered = array.filter { it % 2 == 0 }
							</code>
						</pre>
						Checking if an array contains an element
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								array.contains(3) // returns true
							</code>
						</pre>
						Sorting, reversing, and shuffling an array
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								val sorted = array.sort() // in ascending order

								val reversed = array.reverse()

								val shuffled = array.shuffle()
							</code>
						</pre>
					</div>
					<div>
						<em>
							We will talk more about array and collection operations in the next lessons.
						</em>
					</div>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Collections</h2>
			</section>
			<section>
				<h3>Collections</h3>
				<div class="summary">
					Collection is a group of <span class="highlight">variable number</span> of objects of the same type (and its subtypes).
				</div>
				<div class="content">
					<div>
						<p>
							The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps.
							A pair of interfaces represent each collection type:
						</p>
					</div>
					<div class="row">
						<div class="column">
							<ul>
								<li>
									<span class="highlight">read-only interface</span>
									<br />
									provides operations for accessing collection elements.
								</li>
								<li>
									<span class="highlight">mutable interface</span>
									<br />
									extends the corresponding read-only interface with write operations: adding, removing, and updating its elements.
								</li>
							</ul>
							<p>
								See Kotlin <a href="https://kotlinlang.org/docs/collections-overview.html#collection-types">documentation</a> for more details.
							</p>
						</div>
						<div class="column">
							<img src="./src/img/collections-diagram.png" style="padding-left: 20px"/>
						</div>
					</div>
				</div>
			</section>

			<section>
				<h3>Collections</h3>
				<div class="summary">
					There are 3 main types of collections in Kotlin: lists, sets, and maps.
				</div>
				<div class="content">
					<h4>Lists</h4>
					<p>
						Lists are <strong>ordered</strong> collections of elements that <strong>can contain duplicates</strong> and individual elements can be accessed by their index.
					</p>
					<h4>Sets</h4>
					<p>
						Sets are <strong>unordered</strong> collections of unique elements, meaning order is not guaranteed, and they <strong>don't allow duplicate elements</strong>.
					</p>
					<p>
						You can work with a set just like you would with a list, but there are some differences:
					</p>
					<ul>
						<li>You cannot access elements by index, because sets are unordered.</li>
						<li>Adding an element that already exists in the set will not add a duplicate.</li>
						<li>Removing an element that does not exist in the set will not throw an exception.</li>
					</ul>
					<br />
					<br />
					<h4>Maps</h4>
					<p>
						Maps are collections of <strong>key-value pairs</strong>, where <strong>keys are unique</strong> and are used to access values. Values can be duplicates.
					</p>
					<p>
						<em>
							Kotlin provides standard library functions for working with collections, which we will explore in more detail.
						</em>
					</p>
				</div>
			</section>
			<section>
				<h3>Constructing Collections</h3>
				<div class="summary">
					There are standard library functions for constructing collections in Kotlin for both read-only and mutable collections.
				</div>
				<div class="content">
					<p>
						Collections are constructed using functions <code class="inline">listOf&lt;Type&gt;()</code>,
						<code class="inline">setOf&lt;Type&gt;()</code>
						or <code class="inline">mapOf&lt;KeyType, ValueType&gt;()</code> for read-only collections.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf&lt;String&gt;()

							val set = setOf&lt;Int&gt;()

							val map = mapOf&lt;String, Int&gt;()
						</code>
					</pre>
					<p>
						Or by variable type declaration.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list: List&lt;String&gt; = listOf()
						</code>
					</pre>
					<p>
						If type can be inferred from the elements, you can omit the type declaration.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							val set = setOf(2020, 2021, 2022, 2023, 2024, 2025)

							val map = mapOf(
								"Java" to 1995,
								"Kotlin" to 2011,
								"JavaScript" to 1995,
								"TypeScript" to 2012,
								"Python" to 1991
							)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Constructing Collections</h3>
				<div class="summary">
					There are standard library functions for constructing collections in Kotlin for both read-only and mutable collections.
				</div>
				<div class="content">
					<p>
						Mutable collections can be created using <code class="inline">mutableListOf&lt;Type&gt;()</code>,
						<code class="inline">mutableSetOf&lt;Type&gt;()</code>
						and <code class="inline">mutableMapOf&lt;KeyType, ValueType&gt;()</code>.
					</p>
					<p>
						To construct an empty collection, you can use the <code class="inline">emptyList&lt;Type&gt;()</code>,
						<code class="inline">emptySet&lt;Type&gt;()</code>
						or <code class="inline">emptyMap&lt;KeyType, ValueType&gt;()</code> functions.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val emptyList = emptyList&lt;String&gt;()

							val emptySet = emptySet&lt;Int&gt;()

							val emptyMap = emptyMap&lt;String, Int&gt;()
						</code>
					</pre>
					<p>
						Similarly, empty collections can be created <code class="inline">emptyMutableList&lt;Type&gt;()</code>,
						<code class="inline">emptyMutableSet&lt;Type&gt;()</code>
						and <code class="inline">emptyMutableMap&lt;KeyType, ValueType&gt;()</code> functions.
					</p>
				</div>
			</section>
			<section>
				<h3>Arrays vs. Collections</h3>
				<div class="summary">
					Both arrays and Collections are used to store data. <br />
					There are however some notable differences that make them suitable for different use cases.
				</div>
				<div class="content">
					<table>
						<thead>
						<tr style="font-weight: bold">
							<td></td>
							<td>Arrays</td>
							<td>Collections</td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td style="font-weight: bold">Size</td>
							<td>Arrays have fixed size. This may lead to memory wastage, but is also inconvenient to work with.</td>
							<td>Collections can grow or shrink dynamically to accommodate the data.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Type Safety</td>
							<td>Arrays are type-safe</td>
							<td>Collections are type-safe (through generic typing)</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Performance</td>
							<td>Arrays can perform better than collections for some operations because of their simpler memory layout, lower overhead, and ability to employ direct indexing.</td>
							<td>Collections have more overhead than arrays, and certain operations may be slower as a result. However, the built-in utilities in collections make them more convenient for complex data manipulation.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Functionality</td>
							<td>Arrays offer basic functionality such as adding elements, getting elements, and modifying existing elements.</td>
							<td>
								Collections provide a wide variety of functionalities.
								They can be sorted, reversed, shuffled. They support operations like addition, inspection, modification, deletion, searching and other.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Use Cases</td>
							<td>Arrays are best for fixed-size collections where performance is critical.</td>
							<td>Collections are best for dynamic collections with rich functionality and advanced operations.</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Collections: Kotlin vs. Java</h3>
				<div class="summary">
					Collections in Kotlin are actually one of the most significant differences between Kotlin and Java,
					because they are implemented differently in Kotlin.
				</div>
				<div class="content">
					<table>
						<thead>
						<tr>
							<td style="font-weight: bold"></td>
							<td style="font-weight: bold">Java</td>
							<td style="font-weight: bold">Kotlin</td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td style="font-weight: bold">Null Safety</td>
							<td>Collections can contain null values unless explicitly handled.</td>
							<td>Collections are null-safe by default. You can explicitly declare nullable collections if needed.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Read-Only vs Mutable</td>
							<td>Collections are mutable by default. Read-only views can be created using utility methods.</td>
							<td>Distinguishes between read-only (List, Set, Map) and mutable (MutableList, MutableSet, MutableMap) collections.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Higher-Order Functions</td>
							<td>Introduced lambda expressions and streams in Java 8, but the syntax is more verbose compared to Kotlin.</td>
							<td>Supports higher-order functions and lambda expressions, making it easier to perform operations like filtering, mapping, and reducing.</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Default Implementations</td>
							<td>Requires more boilerplate code for common operations.</td>
							<td>Provides default implementations for many collection operations, making the code more concise.</td>
						</tr>
						</tbody>
					</table>
					<blockquote>
						Note that because Java and Kotlin are fully interoperable,
						you can opt to use Java implementations of collections in Kotlin, if needed.
					</blockquote>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Operations</h2>
			</section>
			<section>
				<h3>Operations</h3>
				<div class="summary">
					The Kotlin standard library provides a rich set of functions for working with collections.
				</div>
				<div class="content">
					<p>
						Collection operations are declared in the standard library in two ways:
					</p>
					<ol>
						<li>
							<strong class="highlight">Member functions of collection interfaces</strong>
							<em>defining operations that are essential for the collection type.</em>
						</li>
						<li>
							<strong class="highlight">Extension functions</strong>
							<em>providing additional functionality.</em>
						</li>
					</ol>
					<p>
						This is important to know in case you want to implement you own collection type as you will need
						to implement all functions in the given interface(s).
					</p>
					<p>
						Some of the common operations on collections include:
					</p>
					<ul>
						<li>Transformations</li>
						<li>Filtering</li>
						<li>plus and minus operators</li>
						<li>Grouping</li>
						<li>Retrieving collection parts</li>
						<li>Retrieving single elements</li>
						<li>Ordering</li>
						<li>Aggregate operations</li>
					</ul>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Adding, Removing and Retrieving Elements</h2>
			</section>
			<section>
				<h3>Adding Elements</h3>
				<div class="content">
					<p>
						For immutable collections, you can use the <code class="inline">plus()</code> function to create a new collection with the added element.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = mutableListOf("Java", "Kotlin", "JavaScript", "TypeScript")

							list.plus("Python")
						</code>
					</pre>
					<p>
						For mutable collections, you can use the <code class="inline">add()</code>,
						<code class="inline">addFirst()</code>, <code class="inline">addLast()</code>
						and <code class="inline">addAll()</code>functions to add an elements to the collection.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val mutableList = mutableListOf("Java", "Kotlin")

							mutableList.add("C#")
							mutableList.addLast("Rust")
							mutableList.addAll(listOf("JavaScript", "TypeScript"))
						</code>
					</pre>

					<p>
						For both mutable and immutable collections, you can use the <code class="inline">+</code> operator to create a new collection with the added element.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val newList = list + "Python"
						</code>
					</pre>
					<p>
						You can also add elements to mutable collections using the <code class="inline">+=</code> operator.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							mutableList += "Python"
						</code>
					</pre>
					<p>
						And finally, you can use the <code class="inline">addAll()</code>,
						<code class="inline">addFirst()</code>, and <code class="inline">addLast()</code> functions to add multiple elements to a mutable collection.
					</p>
				</div>
			</section>
			<section>
				<h3>Removing Elements</h3>
				<div class="content">
					<p>
						Removing elements is similar.
					</p>
					<p>
						Immutable collections provide the
						<code class="inline">minus()</code> function and the
						<code class="inline">-</code> operator to create a new collection with the removed element.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = mutableListOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							val newList = list - "JavaScript"
						</code>
					</pre>
					<p>
						Mutable collections provide the
						<code class="inline">remove()</code>,
						<code class="inline">removeFirst()</code>,
						<code class="inline">removeLast()</code>
						<code class="inline">removeAt()</code>,
						<code class="inline">removeAll()</code>
						and also <code class="inline">removeIf()</code> functions to remove an element from the collection.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val mutableList = mutableListOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							// removes element "JavaScript"
							mutableList.remove("JavaScript")

							// removes element at index 2
							mutableList.removeAt(2)

							// removes elements "Java" and "Kotlin"
							mutableList.removeAll(listOf("Java", "Kotlin"))

							// removes elements with length > 5
							mutableList.removeIf { it.length > 5 }
						</code>
					</pre>
					<p>
						You can also use the <code class="inline">-=</code> operator to remove an element from a mutable collection.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							mutableList -= "JavaScript"
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Retrieving Elements</h3>
				<div class="content">
					<p>
						Retrieving elements from a collection is straightforward and similar to arrays.
					</p>
					<p>
						Here are few examples:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							// get element at index 2
							val element = list[2]

							// get first element
							val first = list.first()

							// get last element
							val last = list.last()

							// get element at index 2 or return "C++" if index is out of bounds
							val elementAtOrElse = list.getOrElse(2) { "C++" }

							// get element at index 10 or return null if index is out of bounds
							val elementAtOrNull = list.getOrNull(10)

							// you can also use the random() function to get a random element from the collection
							val randomElement = list.random()
						</code>
					</pre>
				</div>
			</section>
			<section>
				<div>
					<h3>Retrieving collection parts</h3>
					<div class="content">
						<p>
							You are not limited to retrieving single elements from a collection. You can also retrieve parts of a collection, or slices.
						</p>
						<p>
							These are some of the functions available in the Kotlin SDK:
						</p>
						<ul>
							<li><code class="inline">slice</code> - returns a list of elements at the specified indices.</li>
							<li><code class="inline">take</code> - returns a list of the first n elements.</li>
							<li><code class="inline">takeLast</code> - returns a list of the last n elements.</li>
							<li><code class="inline">takeWhile</code> - returns a list of elements that match the predicate.</li>
							<li><code class="inline">drop</code> - returns a list of elements after the first n elements.</li>
							<li><code class="inline">dropLast</code> - returns a list of elements before the last n elements.</li>
							<li><code class="inline">dropWhile</code> - returns a list of elements after the first element that does not match the predicate.</li>
						</ul>
					</div>
				</div>
			</section>
			<!--			<section>-->
			<!--				<h3>Exercise</h3>-->
			<!--				<div class="content">-->
			<!--				</div>-->
			<!--			</section>-->
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Traversing Collections</h2>
			</section>
			<section>
				<h3>Iterators</h3>
				<div class="summary">
					Kotlin provides standard library functions for traversing collections using iterators.
				</div>
				<div class="content">
					<p>
						Iterators can be obtained for collections that implement the <code class="inline">Iterable</code> interface
						by calling the <code class="inline">iterator()</code> function.
						<br />
						Once you have an iterator, you can traverse the collection using the <code class="inline">next()</code>
						and <code class="inline">hasNext()</code> functions.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							val iterator = list.iterator()

							while (iterator.hasNext()) {
								println(iterator.next())
							}
						</code>
					</pre>
					<p>
						For List, there is a <code class="inline">ListIterator</code>, which allows traversing the list in reverse order
						by using the <code class="inline">previous()</code> function.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							while (listIterator.hasPrevious()) {
								println(listIterator.previous())
							}
						</code>
					</pre>
					<p>
						For mutable collections, you can use the <code class="inline">MutableIterator</code>,
						which provides a <code class="inline">remove()</code> function to remove elements from the collection.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val mutableList = mutableListOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							val iterator = mutableList.iterator()

							while (iterator.hasNext()) {
								val element = iterator.next()
								if (element == "JavaScript") {
									iterator.remove()
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>For Loop</h3>
				<div class="summary">
					You can use a <code class="inline">for</code> loop to iterate over collections that implement
					the <code class="inline">Iterable</code> interface <br />(or its subtypes).
				</div>
				<div class="content">
					<p>
						Iterators are not the most idiomatic way to iterate over collections,
						so Kotlin provides other ways to iterate over collections which implement the <code class="inline">Iterable</code> interface.
					</p>
					<p>
						One of such ways is to use a <code class="inline">for</code> loop.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							for (element in list) {
								println(element)
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>The forEach Function</h3>
				<div class="summary">
					Another way to iterate over collections is to use the <code class="inline">forEach</code> function.
				</div>
				<div class="content">
					<p>
						The <code class="inline">forEach</code> function is a higher-order function that takes a lambda as an argument.
						The basic syntax is ...
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							list.forEach {
								println(it)
							}
						</code>
					</pre>
					<p>
						By default, the lambda passed to the <code class="inline">forEach</code> function takes a single argument,
						which can be referenced using the <code class="inline">it</code> keyword.
					</p>
					<p>
						You can also specify the argument name explicitly (in this case, <code class="inline">element</code>).
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							list.forEach { element ->
								println(element)
							}
						</code>
					</pre>
					<p>
						There is also a shorthand syntax for the lambda if it takes a single argument.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							list.forEach(::println)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>The forEachIndexed Function</h3>
				<div class="summary">
					You can use the <code class="inline">forEachIndexed</code> function to iterate over collections with index.
				</div>
				<div class="content">
					<p>
						The <code class="inline">forEachIndexed</code> function is similar to the <code class="inline">forEach</code> function,
						but it also provides the index of the element as the first argument to the lambda. This may be useful in some situations.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val list = listOf("Java", "Kotlin", "JavaScript", "TypeScript", "Python")

							list.forEachIndexed { index, element ->
								println("Element at index $index is $element")
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Collection Transformations</h2>
			</section>
			<section>
				<h3>Collection Transformations</h3>
				<div class="summary">
					There are many operations that can be performed on collections to transform them in some way which are
					part of the Kotlin SDK.
				</div>
				<div class="content">
					<p>
						Some common transformation operations performed on collections include:
					</p>
					<ul>
						<li>
							<strong class="highlight">map</strong>
							using functions like
							<code class="inline">map</code>,
							<code class="inline">flatMap</code>,
							<code class="inline">mapNotNull</code>,
							<code class="inline">mapIndexed</code>,
							<code class="inline">mapIndexedNotNull</code>.
						</li>
						<li>
							<strong class="highlight">filter</strong>
							using functions like
							<code class="inline">filter</code>,
							<code class="inline">filterNot</code>,
							<code class="inline">filterIndexed</code>,
							<code class="inline">filterNotNull</code>,
							<code class="inline">distinct</code>,
							<code class="inline">distinctBy</code>.
						</li>
						<li>
							<strong class="highlight">sort</strong>
							using functions like
							<code class="inline">sorted</code>,
							<code class="inline">sortedBy</code>,
							<code class="inline">sortedWith</code>,
							<code class="inline">sortedDescending</code>,
							<code class="inline">sortedByDescending</code>,
							<code class="inline">reversed</code>,
							<code class="inline">shuffled</code>.
						</li>
						<li>
							<strong class="highlight">group</strong>
							using functions like
							<code class="inline">groupBy</code>,
							<code class="inline">partition</code>,
							<code class="inline">associate</code>,
							<code class="inline">associateBy</code>,
							<code class="inline">associateWith</code>.
						</li>
						<li>
							<strong class="highlight">plus, minus</strong>
							to add or remove elements from a collection.
						</li>
						<li>
							<strong class="highlight">other transformation</strong>
							functions like
							<code class="inline">reduce</code>,
							<code class="inline">zip</code>,
							<code class="inline">zipWithNext</code>,
							<code class="inline">unzip</code>,
							<code class="inline">flatten</code>,
							<code class="inline">fold</code>.
						</li>
					</ul>
					<p>
						All of these transformations return a new collection with the transformation applied,
						they do not modify the original collection.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Mapping Functions</h2>
			</section>
			<section>
				<h3>mapping functions</h3>
				<div class="summary">
					<code class="inline">map</code> is a transformation operation that applies a function to each element in the collection
					and returns a new collection with the results.
				</div>
				<div class="content">
					<p>
						The returned collection can be of any type, not necessarily the same as the original collection.
					</p>
					<p>
						There are several map functions available in the Kotlin standard library:
					</p>
					<ul>
						<li>
							<code class="inline">map</code>
							- applies a function to each element and returns a list of the results.
						</li>
						<li>
							<code class="inline">mapNotNull</code>
							- applies a function to each element and returns a list of non-null results.
						</li>
						<li>
							<code class="inline">mapIndexed</code>
							- applies a function to each element and its index and returns a list of the results.
						</li>
						<li>
							<code class="inline">mapIndexedNotNull</code>
							- applies a function to each element and its index and returns a list of non-null results.
						</li>
						<li>
							<code class="inline">flatMap</code>
							- applies a function to each element and returns a list of the results, which are then flattened into a single list.
						</li>
						<li>
							<code class="inline">mapTo, mapIndexedTo, mapNotNullTo, etc ... </code>
							- applies a function to each element and adds the results to the given destination.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Exercise #1</h3>
				<div class="content">
					<p>
						Assume you have two lists containig character names. Each list contains characters form different fractions.
						<br />
						For example:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val jediNames = listOf("Luke Skywalker", "Yoda", "Obi-Wan Kenobi", "Mace Windu", "Qui-Gon Jinn")
							val sithNames = listOf("Darth Vader", "Emperor Palpatine", "Darth Maul", "Kylo Ren", "Count Dooku")
							val rebelNames = listOf("Leia Organa", "Han Solo", "Chewbacca", "C3PO", "R2D2")
							val imperialNames = listOf("Stormtrooper", "Imperial Officer", "Imperial Guard", "Death Trooper", "TIE Fighter Pilot")
						</code>
					</pre>
					<p>
						Create the following classes:
					</p>
					<ol>
						<li>
							<code class="inline">StarWarsCharacter</code> with properties <code class="inline">name: String</code> and <code class="inline">fraction: Fraction</code>.
						</li>
						<li>
							<code class="inline">Fraction</code> enum with values
							<code class="inline">JEDI</code>,
							<code class="inline">SITH</code>,
							<code class="inline">REBEL</code>,
							<code class="inline">IMPERIAL</code>,
							etc ...
						</li>
					</ol>
					<p>
						Write code to convert each character name to a <code class="inline">StarWarsCharacter</code> object.
					</p>
					<ul>
						<li>
							<sub>
								<strong>Hint:</strong> Try to create the conversion as extension function on <code class="inline">String</code>,
								accepting a <code class="inline">Fraction</code> as an argument.
							</sub>
						</li>
					</ul>
					<p>
						Finally convert both lists to a list of <code class="inline">StarWarsCharacter</code> objects.
					</p>
					<blockquote>
						Feel free to chose a different theme if you don't like StarWars.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Exercise #2</h3>
				<div class="content">
					<p>
						Create a function that will accept the two lists of <strong>StarWarsCharacter</strong> objects,
						and will pair each character from the first list with a character from the second list.
					</p>
					<ul>
						<li>To do so, use the <code class="inline">mapIndexed</code> function.</li>
						<li>The return type should be <code class="inline">List&lt;Pair&ltlStarWarsCharacter, StarWarsCharacter&gt;&gt;</code></li>
						<li>Make sure to handle the case where characters cannot be paired.</li>
					</ul>
					<p>
						Call the function and save it's return value to a variable. You should now have something like:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							listOf(
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to StarWarsCharacter("Darth Vader", Fraction.SITH),
								StarWarsCharacter("Yoda", Fraction.JEDI) to StarWarsCharacter("Emperor Palpatine", Fraction.SITH),
							)
						</code>
					</pre>
					<p>
						Create a simulated <code>round</code> function to simulate a fight between the characters.
						You can just pick a random winner.
						Return match result as a <code class="inline">List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt;</code>.
					</p>
					<p>Example:</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							listOf(
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 0,
								StarWarsCharacter("Darth Vader", Fraction.SITH) to 1,
								// ...
							)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exercise #3</h3>
				<div class="content">
					<p>
						Call the <code>map</code> function on the list of pairs from the previous exercise,
						use the <code class="inline">round</code> and save the result to a variable.
					</p>
					<p>
						Update the code so that each character pair performs 3 matches. This will give you
						<br />
						<code class="inline">List&lt;List&lt;Pair&lt;Int, List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt;&gt;&gt;&gt;</code>
						<br />
						where the data structure reflects
						<br />
						<code class="inline">listOf(roundNumber to listOf(character to score))</code>.
					</p>
					<p>
						The result should look like this:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val exampleResult: List&lt;List&lt;Pair&lt;Int, List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt;&gt;&gt;&gt; = listOf(
								listOf(
									1 to listOf(
										StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 0,
										StarWarsCharacter("Darth Vader", Fraction.SITH) to 1,
									),
									2 to listOf(
										StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 1,
										StarWarsCharacter("Darth Vader", Fraction.SITH) to 0
									),
									// 3 to listOf(...)
								),
								listOf(
									1 to listOf(
										StarWarsCharacter("Yoda", Fraction.JEDI) to 0,
										StarWarsCharacter("Emperor Palpatine", Fraction.SITH) to 1
									),
									2 to listOf(
										StarWarsCharacter("Yoda", Fraction.JEDI) to 0,
										StarWarsCharacter("Emperor Palpatine", Fraction.SITH) to 1
									),
									// 3 to listOf(...)
								),
								// listOf(...)
							)
						</code>
					</pre>
					<p>
						Extract the code into a function. We might use it later. Again, it might be nice to create it
						as extension function.
					</p>
				</div>
			</section>
			<section>
				<h3>Exercise #4</h3>
				<div class="content">
					<p>
						Create another function which will perform a match called <code class="inline">matchWithFlatResults</code>.
						This function will perform the same thing as <code class="inline">match</code> except it will
						return a flat list of results.
						<br />
						<code class="inline">List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt;</code>
						<br />
						where the data structure reflects
						<br />
						<code class="inline">listOf(character to score)</code>.
					</p>
					<p>
						The result should look like this:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val exampleResult: List&lt;Pair&lt;StarWarsCharacter, Int&gt;&gt; = listOf(
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 0,
								StarWarsCharacter("Darth Vader", Fraction.SITH) to 1,
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI) to 1,
								StarWarsCharacter("Darth Vader", Fraction.SITH) to 0
								StarWarsCharacter("Yoda", Fraction.JEDI) to 0,
								StarWarsCharacter("Emperor Palpatine", Fraction.SITH) to 1
								StarWarsCharacter("Yoda", Fraction.JEDI) to 0,
								StarWarsCharacter("Emperor Palpatine", Fraction.SITH) to 1
								// ...
							)
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Filtering Functions</h2>
			</section>
			<section>
				<h3>Filtering</h3>
				<div class="summary">
					Kotlin SDK again provides us with a rich set of functions for filtering collections.
					Like map, filter returns a new collection with the elements that satisfy a predicate.
				</div>
				<div class="content">
					<p>
						Generally, the returned collection is the same type as the original collection.
					</p>
					<p>
						Some of the filter functions available in the Kotlin standard library include:
					</p>
					<ul>
						<li>
							<code class="inline">filter</code>
							- filters elements based on a predicate and returns a list of elements that satisfy the predicate.
						</li>
						<li>
							<code class="inline">filterNot</code>
							- filters elements based on a predicate and returns a list of elements that do not satisfy the predicate.
						</li>
						<li>
							<code class="inline">filterNotNull</code>
							- filters out null elements and returns a list of non-null elements.
						</li>
						<li>
							<code class="inline">filterIndex</code>
							- filters elements based on a predicate with index and returns a list of elements that satisfy the predicate.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<p>
						Using code from the previous exercise, create a list of characters for each fraction.
					</p>
					<p>
						Example:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val characters = listOf(
								StarWarsCharacter("Luke Skywalker", Fraction.JEDI),
								StarWarsCharacter("Yoda", Fraction.JEDI),
								StarWarsCharacter("Obi-Wan Kenobi", Fraction.JEDI),
								StarWarsCharacter("Mace Windu", Fraction.JEDI),
								StarWarsCharacter("Qui-Gon Jinn", Fraction.JEDI),
								StarWarsCharacter("Darth Vader", Fraction.SITH),
								StarWarsCharacter("Emperor Palpatine", Fraction.SITH),
								StarWarsCharacter("Darth Maul", Fraction.SITH),
								StarWarsCharacter("Kylo Ren", Fraction.SITH),
								StarWarsCharacter("Count Dooku", Fraction.SITH),
								StarWarsCharacter("Leia Organa", Fraction.REBEL),
								StarWarsCharacter("Han Solo", Fraction.REBEL),
								StarWarsCharacter("Chewbacca", Fraction.REBEL),
								StarWarsCharacter("C3PO", Fraction.REBEL),
								StarWarsCharacter("R2D2", Fraction.REBEL),
								StarWarsCharacter("Stormtrooper", Fraction.IMPERIAL),
								StarWarsCharacter("Imperial Officer", Fraction.IMPERIAL),
								StarWarsCharacter("Imperial Guard", Fraction.IMPERIAL),
								StarWarsCharacter("Death Trooper", Fraction.IMPERIAL),
								StarWarsCharacter("TIE Fighter Pilot", Fraction.IMPERIAL)
							)
						</code>
					</pre>
					<p>
						Filter the collection to get only the characters:
					</p>
					<ol>
						<li>All characters belonging to <code class="inline">JEDI</code> or <code class="inline">REBEL</code> fraction</li>
						<li>All characters NOT belonging to <code class="inline">JEDI</code> or <code class="inline">REBEL</code> fraction</li>
					</ol>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Grouping and Sorting Functions</h2>
			</section>
			<section>
				<h3>Grouping</h3>
				<div class="summary">
					Given a collection, you can group elements based on a key.
				</div>
				<div class="content">
					<p>
						The result of grouping operations is a map where the key is the result of the selector function and the value is a list of elements.
					</p>
					<p>
						Some of the grouping functions available in the Kotlin SDK include:
					</p>
					<ul>
						<li>
							<code class="inline">groupBy</code>
							- groups elements by the result of the given selector function.
						</li>
						<li>
							<code class="inline">partition</code>
							- splits the collection into a pair of lists based on a predicate.
						</li>
						<li>
							<code class="inline">associate</code>
							- creates a map from the elements of the collection.
						</li>
						<li>
							<code class="inline">associateBy</code>
							- creates a map from the elements of the collection using the provided key selector function.
						</li>
						<li>
							<code class="inline">associateWith</code>
							- creates a map from the elements of the collection using the provided value selector function.
						</li>
					</ul>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									val priceList = listOf(
										"Mango" to 20,
										"Apple" to 25,
										"Banana" to 10,
										"Coconut" to 15,
										"Pineapple" to 30,
										"Orange" to 5,
										"Grapes" to 40
									)

									val priceCategory = priceList.groupBy { (_, price) ->
										when (price) {
											in 0..10 -> "Cheap"
											in 11..20 -> "Affordable"
											in 21..30 -> "Expensive"
											else -> "Very Expensive"
										}
									}
								</code>
							</pre>
						</div>
						<div class="column">
							<p>
								Result of this will be:
							</p>
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									Affordable=[(Mango, 20), (Coconut, 15)]
									Expensive=[(Apple, 25), (Pineapple, 30)]
									Cheap=[(Banana, 10), (Orange, 5)]
									Very Expensive=[(Grapes, 40)]
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Sorting</h3>
				<div class="summary">
					Collections can be sorted in various ways using the Kotlin SDK.
				</div>
				<div class="content">
					<ul>
						<li>
							<code class="inline">sorted</code>
							- sorts elements in natural order.
						</li>
						<li>
							<code class="inline">sortedBy</code>
							- sorts elements by the result of the given selector function.
						</li>
						<li>
							<code class="inline">sortedWith</code>
							- sorts elements using the given comparator.
						</li>
						<li>
							<code class="inline">sortedDescending</code>
							- sorts elements in reverse natural order.
						</li>
						<li>
							<code class="inline">sortedByDescending</code>
							- sorts elements by the result of the given selector function in reverse order.
						</li>
						<li>
							<code class="inline">reversed</code>
							- reverses the order of elements in the collection.
						</li>
						<li>
							<code class="inline">shuffled</code>
							- shuffles the elements in the collection.
						</li>
					</ul>
					<p>
						Examples:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								val priceList = listOf(
									"Mango" to 20,
									"Apple" to 25,
									"Banana" to 10,
									"Coconut" to 15,
									"Pineapple" to 30,
									"Orange" to 5,
									"Grapes" to 40
								)

								priceList.sortedBy { (_, price) -> price }

								priceList.sortedByDescending { (_, price) -> price }

								priceList.sortedWith(
									compareBy(
										{ it.first },
										{ it.second }
									)
								)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<p>
						Given code from previous lessons, create light and dark side fractions collections and perform a matchWithFlatResults.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val lightSide = starWarsCharacters.filter { it.fraction in setOf(Fraction.JEDI, Fraction.REBEL) }
							val darkSide = starWarsCharacters.filterNot { it.fraction in setOf(Fraction.JEDI, Fraction.REBEL) }

							val results = createPairs(
								fraction1 = lightSide,
								fraction2 = darkSide
							).matchWithFlatResults()
						</code>
					</pre>
					<p>
						User <code class="inline">groupBy</code> and <code class="inline">sortedBy</code>
						functions to group and sort the results by:
					</p>
					<ul>
						<li>character</li>
						<li>fraction</li>
					</ul>
					<p>
						Use map function to calculate sum of scores by:
					</p>
					<ul>
						<li>character</li>
						<li>fraction</li>
					</ul>
					<p>Sort the scoreboard from highest to the lowest score.</p>
					<p>
						Of course, you may use other functions you know as well.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Other Transformation Functions</h2>
			</section>
			<section>
				<h3>Other Transformation Functions</h3>
				<!--				<div class="summary">-->
				<!--					TODO-->
				<!--				</div>-->
				<div class="content">
					<p>
						There are even more useful transformation functions available in the Kotlin SKD. Some worth mentioning are:
					</p>
					<ul>
						<li>
							<code class="inline">reduce</code>
							- combines elements of a collection into a single value.
						</li>
						<li>
							<code class="inline">zip</code>
							- combines two collections into a single collection of pairs.
						</li>
						<li>
							<code class="inline">zipWithNext</code>
							- combines each element with the next element in the collection.
						</li>
						<li>
							<code class="inline">unzip</code>
							- splits a collection of pairs into two collections.
						</li>
						<li>
							<code class="inline">flatten</code>
							- flattens a collection of collections into a single collection.
						</li>
						<li><code class="inline">fold</code>
							- combines elements of a collection into a single value starting with an initial value.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="content">
					<ol>
						<li>
							Remember how we used <code class="inline">mapIndexed</code> to create a list of pairs of characters?
							Try using <code class="inline">zip</code> instead.
						</li>
						<li>
							Try <code class="inline">unzip</code> the list of pairs into two separate lists.
							And why not try <code class="inline">zipWithNext</code>? Just for fun.
						</li>
						<li>
							Try to use <code class="inline">groupBy</code>, <code class="inline">map</code> and <code class="inline">reduce</code>
							to create the scoreboard by character.
						</li>
						<li>
							Try use <code class="inline">fold</code> to create the scoreboard by fraction.
						</li>
					</ol>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Sequence</h2>
			</section>
			<section>
				<h3>Sequence</h3>
				<div class="summary">
					Kotlin standard library provides a <span class="highlight">Sequence</span> additional to collections.
				</div>
				<div class="content">
					<p>
						Unlike collections, sequences don't contain elements, they produce them while iterating.
						This is useful when you need to perform multi-step operations on a collection.
					</p>
					<p>
						<strong class="highlight">Operations on collections are executed eagerly</strong>, meaning they perform all operations on all elements immediately.
						<br />
						<strong class="highlight">Operations sequences are executed lazily</strong>, meaning they perform operations on elements only when needed.
					</p>
					<p>
						This can be beneficial for large collections or when you need to perform complex operations on elements.
						<br />
						On the other hand, sequences may be less efficient for small collections or simple operations.
					</p>
					<p>
						Sequences offer the similar functions as collections, such as <code class="inline">forEach</code>, <code class="inline">map</code>, <code class="inline">filter</code>, etc.
					</p>
					<p>
						The main difference is that when working with sequences, we distinguish between <span class="highlight">intermediate and terminal operations</span>,
						where intermediate operations return a new sequence and terminal operations return a result.
					</p>
					<p>
						What that means is that <span class="highlight">when you call a terminal operation, all intermediate operations are executed and the collection is so called "consumed"</span>.
					</p>
					<blockquote>
						<strong>!!!</strong>&nbsp;&nbsp;&nbsp;
						Keep this in mind because if you call a terminal operation prematurely, you may either end up with unexpected results,
						or at least with a performance hit.
						&nbsp;&nbsp;&nbsp;<strong>!!!</strong>
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Creating Sequences</h3>
				<div class="content">
					From elements:<br />
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val sequence = sequenceOf(1, 2, 3, 4, 5)
						</code>
					</pre>
					From an Iterable:<br />
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val sequence = listOf(1, 2, 3, 4, 5).asSequence()
						</code>
					</pre>
					From a function:<br />
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val sequence = generateSequence(1) { it + 1 }
						</code>
					</pre>
					From chunks:<br />
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val sequence = sequence {
								for (i in 1..5) {
									yield(i)
								}
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Practice</h2>
				<em>↓</em>
			</section>
			<section>
				<h3>Practice: part 1</h3>
				<div class="summary">
					Going back to lesson 5, extend the fantasy game model as follows.
				</div>
				<div class="content">
					<p>
						<strong>I will check your solutions tomorrow!</strong>
					</p>
					<ol>
						<li>
							Create new class <strong>Match</strong> with properties:
							<ul>
								<li><code class="inline">rounds: Int</code></li>
								<li><code class="inline">challenger: Character</code></li>
								<li><code class="inline">opponent: Character</code></li>
							</ul>
						</li>
						<li>
							And a function <code class="inline">fight</code> to the <strong>Match</strong> class
							that will simulate the match and return the winner as <code class="inline">Character?</code>.
							<br />
							You can use code from your previous solution,
							and use the <code class="inline">rounds</code> variable set number of rounds.
						</li>
						<li>
							Update your <strong>main</strong> function to create a <strong>Match</strong> object and execute the fight.
						</li>
					</ol>
				</div>
				<br />
				<br />
				<br />
				<em>Continue to part 2 ↓</em>
			</section>
			<section>
				<h3>Practice: part 2</h3>
				<div class="content">
					<ol>
						<li>
							Create a new interface <code class="inline">Recoverable</code> with with two functions:
							<ul>
								<li><code class="inline">beforeRounds</code></li>
								<li><code class="inline">afterRound</code></li>
							</ul>
						</li>
						<li>
							Extend <strong>Character</strong> with the <code class="inline">Recoverable</code> interface.
						</li>
						<li>
							Update <strong>Warrior</strong> and <strong>Sorcerer</strong> classes to implement the <code class="inline">Recoverable</code> interface.
							<ul>
								<li>
									<code class="inline">beforeRounds</code> should increase the <code class="inline">stamina</code> and <code class="inline">mana</code> by 1.
								</li>
								<li>
									<code class="inline">afterRound</code> - should do nothing for now.
								</li>
							</ul>
						</li>
						<li>
							Update <strong>Match</strong> <code class="inline">fight</code> function to call <code class="inline">beforeRounds</code> and <code class="inline">afterRound</code> functions.
						</li>
					</ol>
				</div>
				<br />
				<br />
				<br />
				<em>Continue to part 3 ↓</em>
			</section>
			<section>
				<h3>Practice: part 3</h3>
				<div class="content">
					<ol>
						<li>
							Create a new enum class <code class="inline">CharacterLevel</code> with 10 levels.
							The enum should have points property which will represent the level points which you can distribute to the character attributes.
							Chose the number of points you want to distribute.
						</li>
						<li>
							Update the <strong>Character</strong> class to have a new abstract property <code class="inline">level</code> of type <code class="inline">CharacterLevel</code>.
						</li>
						<li>
							Add <strong>level</strong> to the <strong>Warrior</strong> and <strong>Sorcerer</strong> classes.
						</li>
						<li>
							Add a constructor validation to each character class to check if the level points are distributed correctly
							(not exceeding maximum level points).
						</li>
					</ol>
				</div>
				<br />
				<br />
				<br />
				<em>Feel free to refactor your code with all the new knowledge.</em>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Practice</h2>
			</section>
		</section>

	</div>
</div>

<script src="./src/dist/reveal.js"></script>
<script src="./src/plugin/notes/notes.js"></script>
<script src="./src/plugin/markdown/markdown.js"></script>
<script src="./src/plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
