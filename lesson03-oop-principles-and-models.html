<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="./src/dist/reset.css">
	<link rel="stylesheet" href="./src/dist/reveal.css">
	<link rel="stylesheet" href="./src/dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="./src/plugin/highlight/vs.css">
	<style>

		.exercise-formatting p {
			/*margin-top: 20px;*/
			margin-bottom: 2px;
			padding-bottom: 5px;
		}
		.exercise-formatting li {
			padding: 0;
			margin-left: 10px
		}
	</style>
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-gradient="var(--kotlin-gradient)">
			<i>Week 1 | Lesson 3</i>
			<h1>OOP Principles & Data Models</h1>
			<em>Programming language and communication of intent</em><br />
			<em>Encapsulation, Polymorphism, Inheritance, Abstraction</em><br />
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Programming language</h2>
				<em>and communication of intent</em>
			</section>
			<section>
				<h3>Communication of intent</h3>
				<div class="summary">
					Programming language provides means of expressing programmer's intent to a computer system.
				</div>
				<div class="content">
					<blockquote>
						But programming it is not just a way of giving instructions to a computer.
						It can also be a means of communication between humans, particularly in the context of team development,
						code reviews, and future maintenance of the software. Here are few points to keep in mind ...
					</blockquote>
					<h4>Code Clarity</h4>
					<p>
						Code is more often read than it is written. Therefore, it is important to keep it clean and easily understood.
					</p>
					<br />
					<h4>Code Consistency</h4>
					<p>
						Keeping your code consistent in terms of syntax, programming style and design patterns makes
						it easier to understand.
					</p>
					<br />
					<h4>Documentation and Comments</h4>
					<p>
						Some code can become hard to understand despite our best effort. In these cases,
						comments and code documentation should be used to clarify the programmer's intent
						or communicate unintuitive information.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Object-oriented Programming</h2>
				<em>Principles in Kotlin</em>
			</section>
			<section>
				<h3>Object-oriented Programming Principles in Kotlin</h3>
				<div class="content content-center content-100">
					<p>Remember, there are four main OOP principles:</p>
					<ol>
						<li>Encapsulation</li>
						<li>Inheritance</li>
						<li>Polymorphism</li>
						<li>Abstraction</li>
					</ol>
					<br />
					<br />
					<p>We will go more into detail of each of how these are handle in Kotlin on the following slides.</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<em>But first ...</em>
				<h2>Objects and Classes</h2>
			</section>
			<section>
				<h3>Objects and Classes</h3>
				<div class="summary">
					We have already seen and worked with Kotlin objects and classes.
					<br />
					Let's explain what they are and how they work in more detail.
				</div>
				<div class="content content-center">
					<br />
					<div>
						<div class="highlight" style="font-size: larger; font-weight: bolder">What is an object?</div><br />
						<div style="font-size: larger; font-style: italic" class="fragment fade-in">Object is a data structure in memory<br /></div>
					</div>
					<br />
					<br />
					<div>
						<div class="highlight" style="font-size: larger; font-weight: bolder">What is a class?</div><br />
						<div style="font-size: larger; font-style: italic" class="fragment fade-in">Class is a template for how to create an object</div>
					</div>
					<br />
					<blockquote class="fragment fade-in">
						Think of a class as a blueprint for creating objects.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Class Definition</h3>
				<div class="summary">
					Class is defined using the <code class="hljs inline">class</code> keyword, followed by the class name,
					class header and the class body.
				</div>
				<div class="content">
					<ul>
						<li>
							<span class="highlight">Class name</span> -
							should begin with an initial letter (capitalized by convention).
						</li>
						<li>
							<span class="highlight">Class header</span> -
							class type parameters, the primary constructor, and other things, such as its superclass or interfaces it implements.
						</li>
						<li>
							<span class="highlight">Class properties</span> -
							are defined in the class header and are used to hold the state of the class and its objects.
						</li>
						<li>
							<span class="highlight">Class body</span> -
							containing properties, methods, constructors, initializer blocks, inner classes, and interfaces enclosed in curly braces.
							<ul>
								<li>
									<span class="highlight">Properties</span> -
									additional properties that hold the state of the class and its objects.
								</li>
								<li>
									<span class="highlight">Methods</span> -
									functions that are part of the class and contain the executable code.
								</li>
								<li>
									<span class="highlight">Constructors</span> -
									special methods used to initialize the state of an object.
								</li>
								<li>
									<span class="highlight">Initializer blocks</span> -
									unnamed code blocks used for initializing shared variables and executing code that needs to run every time an instance of the class is created.
								</li>
								<li>
									<span class="highlight">Inner classes and interfaces</span> -
									class or interface definitions nested within the outer class body.
								</li>
								<li>
									<span class="highlight">Companion objects</span> -
									special objects that are tied to a class, rather than to an instance of a class.
								</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Class Definition</h3>
				<div class="summary">
					Class is defined using the <code class="hljs inline">class</code> keyword, followed by the class name,
					class header (optional), and the class body (optional) enclosed in curly braces.
				</div>
				<div class="content">
					<div>
						Simple class definition without body.
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								class UniversityCourse
							</code>
						</pre>
					</div>
					<div>
						More realistic class definition with parameters and body.
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								class UniversityCourse(
									val subject: String,
									val startDate: LocalDate,
									val endDate: LocalDate,
									val students: MutableList&lt;String&gt; = mutableListOf() // initial value of empty list
								) {

									// class properties which is not part of the constructor
									private var isOpen: Boolean = false // initial value of false

									fun addStudent(studentName: String) {
										if (isOpen) {
											students.add(studentName)
										} else {
											error("Cannot add students to closed course.")
										}
									}

									fun open() {
										isOpen = true
									}

									fun close() {
										isOpen = false
									}
								}
							</code>
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h3>Class Instantiation</h3>
				<div class="summary">
					You do not directly work with classes in Kotlin, you work with objects that are created from classes, called class instances.
				</div>
				<blockquote>
					Object == Instance of a class
				</blockquote>
				<div class="content">
					<ul>
						<li>The process that creates an object from class is called <strong>instantiation</strong></li>
						<li>Instantiation is done by calling a special <strong>constructor</strong> method</li>
						<li>Class may have <strong>one or more</strong> constructors</li>
						<li>If constructor is not explicitly defined, then the class will <strong>default constructor with no arguments</strong></li>
						<li>Instantiation can be used to set initial values for the object</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Class Header</h3>
				<div class="summary">
					Class header defines its type parameters, the primary constructor, and other things,
					such it's superclass or interfaces it implements.
				</div>
				<div class="content">
					<div>
						<ul>
							<li>The class header specifies class properties.</li>
							<li>Just like functions argument, class properties can have default values.</li>
							<li>The declared properties also define the class primary constructor.</li>
							<li>
								In this example, the class header specifies that the class has four properties, one with a default value,
								which means that it can be omitted when creating an instance of the class.
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class UniversityCourse(
											val subject: String,
											val startDate: LocalDate,
											val endDate: LocalDate,
											val students: MutableList&lt;String&gt; = mutableListOf() // initial value of empty list
										) {
											// class body
										}
									</code>
								</pre>
							</li>
						</ul>
					</div>
				</div>
			</section>
			<section>
				<h3>Class Constructors</h3>
				<div class="summary">
					Class constructor is a special method with the only purpose of class instantiation.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							Class with zero arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class KotlinCourse {
										val subject: String = "Kotlin"
									}


									val kotlinCourse = KotlinCourse()
								</code>
							</pre>
							Class with one arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class Course(val subject: String)


									val kotlinCourse = Course("Kotlin")
								</code>
							</pre>
						</div>
						<div class="column">
							Class with multiple arguments constructor
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									class Course(
										val subject: String,
										val startDate: LocalDate,
										val endDate: LocalDate
									)


									val kotlinCourse = Course(
										"Kotlin",
										LocalDate.parse("2024-02-03"),
										LocalDate.parse("2024-02-21")
									)
								</code>
							</pre>
						</div>
					</div>
					<ul>
						<li>Every class has a constructor, even if it is not explicitly defined.</li>
						<li>Class may have multiple constructors (primary and secondary constructors).</li>
						<li>Constructor may have zero, one, or many arguments</li>
						<li>Class constructors support named arguments just like functions.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Alternate class constructors</h3>
				<div class="summary">
					Kotlin allows you to define multiple constructors for a class, also called secondary constructors.
					They provide alternative ways to instantiate the class.
				</div>
				<div class="content">
					Example of class definition, class alternate constructor, and constructor calls.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							// primary constructor defined by class header
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate
							) {

								// alternate constructor
								constructor(
									subject: String,
									startDate: String,
									endDate: String,
								) : this(subject, LocalDate.parse(startDate), LocalDate.parse(endDate))
							}
						</code>
					</pre>
					Primary constructor call with default values
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse1 = UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"), LocalDate.parse("2024-02-21"))
						</code>
					</pre>
					Alternate constructor call
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse3 = UniversityCourse("Kotlin", "2024-02-03", "2024-02-21")
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Default values & Named arguments</h3>
				<div class="summary">
					Just like functions, class constructors can have default values and support named arguments.
				</div>
				<div class="content">
					Class constructor really is just a special kind of function, so just like functions,
					class constructors can have default values and support named arguments.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),    // default date
								val students: MutableList&lt;String&gt; = mutableListOf() // default value of empty list
							) {
								// class body
							}
						</code>
					</pre>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"))
								</code>
							</pre>
						</div>
						<div class="column"><br />Calling the constructor with default values.</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse(
										"Kotlin",
										LocalDate.parse("2024-02-03"),
										students = mutableListOf("Alice", "Bob")
									)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Calling the constructor with one named argument for <strong>students</strong>.
							<br />
							The <strong>endDate</strong> will be set to the default value.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									UniversityCourse(
										subject = "Kotlin",
										startDate = LocalDate.parse("2024-02-03"),
										endDate = LocalDate.parse("2024-02-21"),
										students = mutableListOf("Alice", "Bob")
									)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Naming all arguments when calling the constructor.
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Methods</h3>
				<div class="summary">
					Method is a function associated with an object.<br />
					In Kotlin, you can also call methods member functions.
				</div>
				<div class="content">
					<p>
						Same rules and possibilities apply to methods as to functions not associated with a class.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),
								val students: MutableList&lt;String&gt; = mutableListOf()
							) {

								fun addStudent(studentName: String) {
									students.add(studentName)
								}

								fun removeStudent(studentName: String) {
									students.remove(studentName)
								}

								fun printStudents() {
									students.forEach { println(it) }
								}
							}
						</code>
					</pre>
					<p>
						The only difference is that methods are called on an instance of object.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							val kotlinCourse = UniversityCourse("Kotlin", LocalDate.parse("2024-02-03"))
							kotlinCourse.addStudent("Alice")
							kotlinCourse.addStudent("Bob")
							kotlinCourse.printStudents()
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Initializer blocks</h3>
				<div class="summary">
					Initializer blocks are code that is run when an instance of a class is created.
				</div>
				<div class="content">
					<p>
						For example, this can be used for additional argument validation or to set up some initial state.
					</p>
					<p>
						Class may have one or more initializer blocks, which are executed in the order they are defined.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),
								val students: MutableList&lt;String&gt; = mutableListOf()
							) {

								init {
									require(startDate < endDate) { "End date must be after start date" }
								}

								init {
									println("Course $subject created")
								}

							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Scope and "this" reference</h3>
				<div class="summary">
					In Kotlin, the <code class="inline">this</code> keyword is used to refer to the current instance of a class.
				</div>
				<div class="content">
					It is often used to distinguish between class properties and parameters or local variables with the same name.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class Person(val name: String) {

								fun introduce(name: String) {
									println("${this.name} also goes by $name")
								}

							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val person = Person("Monika")
								person.introduce("Moni") // prints "Monika also goes by Moni"
							}
						</code>
					</pre>
					Additionally, Kotlin provides other scope references using <code class="inline">@label</code> to refer to specific instances in nested scopes.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class A {
								inner class B {
									fun Int.foo() {
										val a = this@A // refers to the instance of A
										val b = this@B // refers to the instance of B
										val c = this // refers to the receiver Int
										println("a: $a, b: $b, c: $c")
									}
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val a = A()
								val b = a.B()
								b.run { 42.foo() }
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Class destruction</h3>
				<div class="summary">
					Java/Kotlin has no class destructor, because freeing up memory is entirely delegated to JVM through
					a process called <strong>garbage collection</strong>, which we will talk about in later in the course.
				</div>
				<div class="content">
					Some Java/Kotlin classes may have a special methods that should be called after we are done using
					the class in order for it to be eligible for garbage collection. I will also mention these
					later in the course.
				</div>
			</section>
			<section>
				<h3>Inner classes</h3>
				<div class="summary">
					Inner class (also called nested class), is a class defined within a body of another class.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class OuterClass {

								private val outerVariable: String = "Outer Variable"

								// Inner class
								inner class InnerClass {
									fun accessOuterVariable(): String {
										return outerVariable
									}
								}
							}
							</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val outer = OuterClass()
								val inner = outer.InnerClass()
								println(inner.accessOuterVariable()) // prints "Outer Variable"
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Use case for nested classes</h3>
				<div class="content">
					<br />
					<h4>Logical Grouping</h4>
					<div>
						Nested classes can help us keep our code organized by having related code together.
						For example, you may want to create an internal data class.
					</div>
					<br />
					<br />
					<!--						</li>-->
					<!--					<li>-->
					<!--						<strong>Access Control</strong>-->
					<!--						<div>-->
					<!--							Inner classes can access members of the outer class, including those marked as private.-->
					<!--							This feature is helpful when you need to create a helper class that needs access to an outer-->
					<!--							class’s properties or methods.-->
					<!--						</div>-->
					<!--					</li>-->
					<!--						<li>-->
					<h4>Encapsulation & Access Control</h4>
					<div>
						Inner classes can access members of the outer class, including those marked as private.
						This can benefit us in multiple scenarios, such us when creating helper classes without exposing
						private methods or properties of the outer class.
						<!--							Consider two top-level classes, A and B, where B needs access to the private members of A.-->
						<!--							We could change the visibility of A's members from private to protected or public to allow B access.-->
						<!--							However, this would also provide access to all other classes which is sometimes not desirable.-->
					</div>
					<br />
					<br />
					<h4>Increased Readability and Maintainability</h4>
					<div>
						Inner classes are used for code that is relevant to a small part of the outer class.
						Grouping them together improves code readability and maintainability.
					</div>
				</div>
			</section>
			<section>
				<h3>Anonymous Classes</h3>
				<div class="summary">
					<!--					Anonymous class is a class which does not have a name.-->
					In Kotlin, anonymous classes are a way to create an instance of a class with certain modifications
					without having to actually declare a new subclass. They are often used to create instances
					of classes that have no name and are used only once.
				</div>
				<!--				<p>-->
				<!--					In Java, an anonymous class is an inner class (a class within another class), which does not have a name.-->
				<!--					Since it has no name, we have no way to instantiate such class. Thus, an anonymous class must be declared and instantiated with a single expression.-->
				<!--				</p>-->
				<div class="content">
					<p>
						Since it has no name, we have no way to instantiate such class.<br />
						Thus, an anonymous class must be declared and instantiated with a single expression.
					</p>
					<p>
						An anonymous class must either implement an interface or extend an existing class (abstract or concrete).
					</p>
					<p>
						<!--						Anonymous classes are helpful when we wish to use a local class only once, but their use is-->
						<!--						generally discouraged in favour of Lambda expression (which I'll explain shortly).-->
						Anonymous classes are useful for creating quick, one-off implementations of interfaces or abstract classes.
					</p>
					<pre>
					<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						fun main() {

							val runnable = object : Runnable {
								override fun run() {
									println("Running in an anonymous class!")
								}
							}

							val thread = Thread(runnable)

							thread.start()
						}
					</code>
				</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Singleton Objects</h2>
				<em>Static classes and constants in Kotlin</em>
			</section>
			<section>
				<h3>Singleton Objects</h3>
				<div class="summary">
					Singleton object is a class that can have only one instance in memory.
				</div>
				<div class="content">
					<p>
						In Java and other languages, we used so called singleton pattern to create a class that can have only one instance.
					</p>
					<p>
						Kotlin provides a convenient way to create singleton objects using the <code class="inline">object</code> keyword.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							object StringUtils {

								val DECIMAL_PLACES = 2

								fun formatNumber(number: Double): String {
									// code to format number
								}

							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val formattedNumber = StringUtils.formatNumber(3.14159)
								println(formattedNumber) // prints "3.14"
							}
						</code>
					</pre>
					<h4>Some key features:</h4>
					<ul>
						<li><strong>Singleton</strong> - Only one instance of the object is created.</li>
						<li><strong>Utility Methods</strong> - Commonly used for utility methods and constants.</li>
						<li><strong>Initialization</strong> - The object is initialized when it is first accessed.</li>
						<li><strong>No Constructors</strong> - Objects cannot have constructors.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Use case for static objects</h3>
				<div class="content">
					<h4>Utility or Helper Classes</h4>
					<p>
						Sometimes we need some methods to be globally available in the application without needing to create class instance every time.
						Example of such is utility classs with static methods is <code class="inline">String.valueOf()</code>
						or <code class="inline">Integer.toBinaryString()</code>.
					</p>
					<br />
					<h4>Global Constants and Variables</h4>
					<p>
						Static keyword can be used to define class level variables hat are accessible throughout our application.
					</p>
					<br />
					<h4>Singleton Pattern</h4>
					<p>
						Kotlin object is equivalent to Java's singleton pattern, but with the convenience of a simpler, error-proof syntax.
						Singleton class is a design pattern that restricts the instantiation of a class to a single instance.
					</p>
				</div>
			</section>
			<section>
				<h3>Companion Objects</h3>
				<div class="summary">
					Companion object is an object that is tied to a class, rather than to an instance of a class.
				</div>
				<div class="content">
					<ul>
						<li>There can be only one companion object per class, and it is defined using the <code class="inline">companion</code> keyword.</li>
						<li>It may have a name, but it is optional. Otherwise, it is referred to as a default companion object.</li>
						<li>It is often used to define static methods and constants.</li>
						<li>Other than that, it is just like any other object.</li>
						<li>Companion objects are by convention placed at the bottom of the class.</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate
							) {

								// regular class methods

								companion object UniversityCourseFactory { // companion object name is optional
									const val KOTLIN = "Kotlin"

									fun kotlinCourse(startDate: String, endDate: String): UniversityCourse {
										return UniversityCourse(KOTLIN, LocalDate.parse(startDate), LocalDate.parse(endDate))
									}
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {

								val kotlinCourse = UniversityCourse.kotlinCourse("2024-02-03", "2024-02-21")

								println(UniversityCourse.KOTLIN) // prints "Kotlin"

							}
						</code>
					</pre>
				</div>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Data Models</h2>
			</section>
			<section>
				<h3>Data Models</h3>
				<div class="summary">
					A data model is a conceptual representation of how data is structured and related in your application.
				</div>
				<div class="content">
					<p>
						A data model defines the shape and structure of data in terms of classes, properties, and relationships.
					</p>
					<ul>
						<li>
							In object-oriented programming, data models are typically expressed using classes
							that reflect real-world entities (e.g., <code>User</code>, <code>User</code>, <code>Product</code>).
						</li>
						<li>
							A good data model serves as a bridge between:
							<ul>
								<li>the <strong>business logic</strong> (how the system behaves),</li>
								<li>the <strong>data storage</strong> (like a database),</li>
								<li>and the <strong>API</strong> layer (how other systems communicate with it).</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<section>
					<h3>Data Classes</h3>
					<div class="summary">
						Kotlin provides a special kind of class called a <code class="inline">data class</code> to make data modeling more concise and expressive.
					</div>
					<div class="content">
						<p>
							For a data class, Kotlin compiler automatically generates convenience methods for copying,
							comparing, and printing objects and more.
						</p>
						<p>
							Data classes are marked with the <code class="inline">data</code> keyword.
						</p>
						<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class UniversityCourse(
								val subject: String,
								val startDate: LocalDate,
								val endDate: LocalDate = startDate.plusDays(30),
								val students: MutableList&lt;String&gt; = mutableListOf()
							)
						</code>
					</pre>
						<p>
							There are a few rules for data classes:
						</p>
						<ul>
							<li>The primary constructor must have at least one parameter.</li>
							<li>Primary constructor must have <code class="inline">val</code> or <code class="inline">var</code> keyword.</li>
							<li>Data classes cannot be abstract, open, sealed, or inner.</li>
							<li>Data classes cannot inherit from other classes.</li>
						</ul>
					</div>
				</section>
			</section>
			<section>
				<section>
					<h3>Enums</h3>
					<div class="summary">
						Enum (enumeration) is a special type of class, which contains a fixed set of constants.
					</div>
					<div class="content">
						<ul>
							<li>Enum is created with the <code class="inline">enum class</code> keyword.</li>
							<li>Enum constants are static and final implicitly.</li>
							<li>By convention, the enum values should be in upper case.</li>
							<li>enums can also have properties, methods, and can be initialized with a constructor.</li>
						</ul>
						<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							enum class Days {
								MONDAY,
								TUESDAY,
								WEDNESDAY,
								THURSDAY,
								FRIDAY,
								SATURDAY,
								SUNDAY
							}
						</code>
					</pre>
						<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val day = Days.MONDAY
								println(day) // prints "MONDAY"
							}
						</code>
					</pre>
					</div>
				</section>

				<section>
					<h3>Enums</h3>
					<div class="summary">
						Since enum is a class, it may have <em>fields</em>, <em>constructors</em> and <em>methods</em>.
					</div>
					<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							enum class Days(val isWorkDay: Boolean) {
								MONDAY(true),
								TUESDAY(true),
								WEDNESDAY(true),
								THURSDAY(true),
								FRIDAY(true),
								SATURDAY(false),
								SUNDAY(false);

								fun isWeekend(): Boolean {
									return !isWorkDay
								}

								fun isWeekday(): Boolean {
									return isWorkDay
								}
							}
						</code>
					</pre>
						<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val day = Days.MONDAY
								println(day) // prints MONDAY
								println(day.isWorkDay()) // prints true
							}
						</code>
					</pre>
					</div>
				</section>

				<section>
					<h3>Enums</h3>
					<div class="summary">
						Enums are particularly useful for evaluating a finite number of states.
					</div>
					<div class="content">
						<p>
							Especially in combination with <code class="inline">when</code> expression.
						</p>
						<p>
							Whenever you use <code class="inline">when</code> with enums, the compiler will check if all possible values are covered.
						</p>
						<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun getHoursInClass(day: Days): Int {
								return when (day) {
									Days.MONDAY,
									Days.TUESDAY,
									Days.THURSDAY -> 4
									Days.WEDNESDAY,
									Days.FRIDAY -> 3
									Days.SATURDAY,
									Days.SUNDAY -> 0
								}
							}
						</code>
					</pre>
						<p>
							In case you forget to cover all possible values, the compiler will throw an error.
							You may also use <code class="inline">else</code> branch to cover all other cases.
						</p>
						<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun getHoursInClass(day: Days): Int {
								return when (day) {
									Days.MONDAY,
									Days.TUESDAY,
									Days.THURSDAY -> 4
									Days.WEDNESDAY,
									Days.FRIDAY -> 3
									else -> 0
								}
							}
						</code>
					</pre>
					</div>
				</section>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<em>OOP Principle #1</em>
				<h2>Encapsulation</h2>
			</section>
			<section>
				<h3>What is Encapsulation</h3>
				<div class="summary">
					Encapsulation is a concept of controlling access to the internal state of an object, protecting it from unauthorized access and ensuring data integrity.
				</div>
				<div class="content">
					<ul>
						<li>
							In Java/Kotlin, this is typically achieved using access modifiers (private, protected, internal) and getter/setter methods.
						</li>
						<li>
							By using getter/setter methods, the class can enforce its own data validation rules to ensure it's internal state remains valid and consistent.
						</li>
					</ul>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							data class Assignment(
								val dueDate: LocalDate,
								val assignee: String,
							) {
								private var finalGrade: Int? = null

								fun getFinalGrade(): Int? {
									return finalGrade
								}

								fun setFinalGrade(finalGrade: Int) {
									require(finalGrade in 0..100) { "Final grade must be between 0 and 100" }
									this.finalGrade = finalGrade
								}
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val assignment = Assignment(LocalDate.now(), "John Doe")
								assignment.setFinalGrade(90)
								println(assignment.getFinalGrade())
							}
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<em>OOP Principle #2</em>
				<h2>Inheritance</h2>
			</section>
			<section>
				<h3>What is Inheritance</h3>
				<div class="summary">
					Inheritance> establishes an <em>"is-a"</em> relationship between two classes,
					where one class inherits properties and methods of the other class.
				</div>
				<div class="content">
					<blockquote>
						The class that inherits is called <strong>subclass</strong> and the class inherited from is called <strong>superclass</strong>.
					</blockquote>
					<ul>
						<li>The class to be inherited from must be marked as <code class="inline">open</code>.</li>
						<li>To define inheritance, the <code class="inline">:</code> symbol is used followed by the superclass name, for example
							<code class="inline">class Dog : Animal()</code>.
						</li>
						<li>If a superclass has a <em>non-default</em> constructor, you must call <code class="inline">super()</code> method in the subclass constructor.</li>
						<li>
							You can mark methods and attributes of a superclass as <code class="inline">protected</code>.
							This will make them only accessible within the same package or within subclass.
						</li>
						<li>You can reference fields and methods in the superclass class using the <code class="inline">super</code> keyword.</li>
						<li>To prevent inheritance, you can mark the class with <code class="inline">final</code> modifier.</li>
					</ul>
					<p>
						<em>Let's have a look at this in detail ...</em>
					</p>
				</div>
			</section>
			<section>
				<h3>Inheritance</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val cat = Cat("meow")
								cat.makeSound()

								val dog = Dog()
								dog.makeSound()

								// this would not compile, because makeRawSound is protected
								// dog.makeRawSound();

								val bird = Bird("tweet")
								bird.makeSound()
							}
						</code>
					</pre>
				</div>
				<div class="content">
					<table>
						<tbody>
						<tr>
							<td>
								<strong>Animal</strong> is base class for all animals.
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										open class Animal(private val sound: String) {

											fun makeSound() {
												println(sound)
											}

											protected fun makeRawSound() {
												println(sound)
											}
										}
									</code>
								</pre>
								<strong>BarkingAnimal</strong> extends <strong>Animal</strong> and adds a bark method.
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										open class BarkingAnimal : Animal("woof") {

											fun bark() {
												makeRawSound()
											}
										}
									</code>
								</pre>
							</td>
							<td>
								Cat extends <strong>Animal</strong> and overrides the sound.
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Cat(sound: String) : Animal(sound)
									</code>
								</pre>
								<strong>Dog</strong> extends <strong>BarkingAnimal</strong> and does not override the sound.
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Dog : BarkingAnimal()
									</code>
								</pre>
								<strong>Bird</strong> extends <strong>Animal</strong> and adds an alternative constructor.
								Notice the use of <code class="inline">super</code>.
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Bird : Animal {

											constructor(song: String) : super(song)

										}
									</code>
								</pre>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Inheritance</h3>
				<div class="summary">
					You can use the <code class="inline">final</code> modifier to prevent method overriding or class inheritance.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							open class Cat {

								final fun meow() {
									System.out.println("meow");
								}

							}
						</code>
					</pre>
					<p>
						We are trying to override the <code class="inline">meow</code> method, the compiler will throw an error.
					</p>
					<pre style="border: 2px red solid;">
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							class MyCat: Cat() {


								// This will not compile
								override fun meow() { }

							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Pros of inheritance</h3>
				<div class="content">
					<p>
						<span class="highlight block">Promotes code reuse</span>
						Inheritance allows subclasses to inherit methods and fields from superclasses which leads to a reduction in code duplication.
					</p>
					<p>
						<span class="highlight block">Promotes polymorphism</span>
						Subclasses can redefine certain methods based on their requirement.
					</p>
					<p>
						<span class="highlight block">Hierarchy and organization</span>
						Inheritance helps to design the software in a hierarchical manner where classes with general characteristics are at a higher level and classes with specific characteristics are at lower level.
					</p>
				</div>
			</section>
			<section>
				<h4>Cons of inheritance</h4>
				<div class="content">
					<p>
						<span class="highlight block">Tight coupling</span>
						A subclass is tightly coupled with its superclass. If the superclass is modified, subclasses could be affected, as they inherit methods and fields from the superclass.
					</p>
					<p>
						<span class="highlight block">Inheritance chain</span>
						Inheritance often leads to long chains which could make tracking down errors in the code difficult.
					</p>
					<p>
						<span class="highlight block">Issues with multiple inheritance</span>
						Kotlin does not support multiple inheritance (a class can’t extend more than one class).<br />
						However, it supports multiple interface implementation, which is a partial workaround for this issue.
					</p>
					<p>
						<span class="highlight block">Memory overhead</span>
						When a subclass object is created, a separate memory space is reserved for it in addition
						to the separate memory space reserved for the superclass object. This might result in
						memory wastage if the subclass makes limited use of the superclass's features.
					</p>
				</div>
			</section>
			<section>
				<h3>Composition</h3>
				<div class="summary">
					Composition provides a <em>"has-a"</em> relationship.
					It allows you to use object instances as fields within the other classes.
				</div>
				<div class="content">
					<h4>Pros</h4>
					<ul>
						<li>Results in loose coupling and improves encapsulation, because the contained objects can be easily swapped without changing the code that uses them.</li>
						<li>Can be used to overcome lack of multiple inheritance in Kotlin.</li>
						<li>Usually allows for better testability as well.</li>
					</ul>
				</div>
				<div class="content">
					<h4>Cons</h4>
					<ul>
						<li>It can result in bloated classes if overused, and requires more code setup than inheritance.</li>
						<li>it can be more difficult to use when requests must be delegated to the appropriate class.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Composition</h3>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val cat = Cat("Garfield")
								cat.meow()
							}
						</code>
					</pre>
				</div>
				<div class="content">
					<table style="width: 100%">
						<tbody>
						<tr>
							<td>
								Composed class
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Cat(val name: String) {

											private val sound = Sound("meow")

											fun meow() {
												sound.makeSound()
											}
										}

									</code>
								</pre>
							</td>
							<td>
								Composition class
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Sound(private val sound: String) {

											fun makeSound() {
												println(sound)
											}
										}
									</code>
								</pre>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Composition and Inheritance</h3>
				<div class="content">
					<blockquote>
						Both inheritance and composition have their strengths and weaknesses.
						Deciding when to use each
						can be instrumental for designing cleaner and more effective code.
						<br />
						<br />
						<strong>The two techniques can be, and often are, combined.</strong>
					</blockquote>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val cat = Cat("Garfield", Sound("meow"))
								cat.makeSound()
							}
						</code>
					</pre>
					<table style="width: 100%">
						<tbody>
						<tr>
							<td>
								Superclass - adding Sound through composition
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										open class Animal(private val sound: Sound) {
											fun makeSound() {
												sound.makeSound()
											}
										}
									</code>
								</pre>
								Composed class - has no dependencies
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Sound(private val sound: String) {
											fun makeSound() {
												println(sound)
											}
										}
									</code>
								</pre>
							</td>
							<td>
								Subclass extending Animal
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Cat(val name: String, sound: Sound) : Animal(sound)
									</code>
								</pre>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<em>OOP Principle #3</em>
				<h2>Polymorphism</h2>
				<p></p>
			</section>
			<section>
				<h3>What is polymorphism</h3>
				<div class="summary">
					In programming, polymorphism allows us to define one interface or method that can have multiple implementations.
					It means that the same method or property could exhibit different behavior in different instances of object implementing given interface.
				</div>
				<div class="content content-center content-100">
					<br />
					<h4>There are two types of polymorphism</h4>
					<ul>
						<li>Compile-Time polymorphism</li>
						<li>Run-Time polymorphism</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Compile-time polymorphism</h3>
				<div class="summary">
					Also known as static polymorphism
				</div>
				<div class="content">
					<p>
						Compile-time polymorphism is achieved through <strong>method overloading</strong>.
						The correct method to call is determined by the compiler at compile time based on the method signature.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						fun main() {

							val result1 = Calculator.add(10, 20)
							val result2 = Calculator.add(10, 20, 30)

							println(result1)    // prints 30
							println(result2)    // prints 60
						}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						object Calculator {

							// method with 2 parameters
							fun add(a: Int, b: Int): Int {
								return a + b
							}

							// overloaded method with 3 parameters
							fun add(a: Int, b: Int, c: Int): Int {
								return a + b + c
							}
						}
						</code>
					</pre>
					<p>
						<span class="highlight">Method overloading</span> = defining two or more methods in a class with the same name but different <strong>signature</strong>.
					</p>
					<p>
						<span class="highlight">Method signature</span> = combination of the method name, return type and the parameters.
					</p>
				</div>
			</section>
			<section>
				<h3>Runtime polymorphism</h3>
				<div class="summary">
					Also known as dynamic method dispatch
				</div>
				<div class="content">
					<p>
						Runtime polymorphism is a process in which a call to an overridden method is resolved at runtime rather than at compile-time.
						This mechanism allows the Java Virtual Machine (JVM) to decide which method to invoke from the class hierarchy at runtime,
						based on the type of object.
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								val animal0 = Animal()

								val animal1: Animal = Dog() // Animal reference but Dog object
								val animal2: Animal = Cat() // Animal reference but Cat object

								animal0.makeSound() // prints "(silence)"
								animal1.makeSound() // prints "woof"
								animal2.makeSound() // prints "meow"
							}
						</code>
					</pre>
					<table style="width: 100%">
						<tbody>
						<tr>
							<td>
								Superclass
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										open class Animal {
											open fun makeSound() {
												println("(silence)")
											}
										}
									</code>
								</pre>
							</td>
							<td>
								Subclass 1
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Dog : Animal() {
											override fun makeSound() {
												println("woof")
											}
										}
									</code>
								</pre>
								Subclass 2
								<pre>
									<code data-trim data-noescape data-line-numbers class="hljs kotlin">
										class Cat : Animal() {
											override fun makeSound() {
												println("meow")
											}
										}
									</code>
								</pre>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<em>OOP Principle #4</em>
				<h2>Abstraction</h2>
			</section>
			<section>
				<h3>Abstract class</h3>
				<div class="summary">
					Abstract is defined using the <code class="inline">abstract</code> keyword <br />
					and are used to define common behavior that can be inherited by subclasses.

				</div>
				<div class="content">
					<p>
						Abstract class cannot be instantiated directly. The main purpose of an abstract class is encapsulating common behavior that can be shared among multiple subclasses,
						while allowing each subclass to implement its own behavior either by overriding abstract methods, adding new methods or fields, or overriding non-abstract methods.
					</p>
					<ul>
						<li>Abstract classes can have constructors, but they cannot be directly instantiated.</li>
						<li>They can contain both abstract and non-abstract methods.</li>
						<li>Abstract methods must be implemented by subclasses.</li>
						<li>Non-abstract methods can be optionally overridden by subclasses.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Abstract class</h3>
				<div class="content">
					<div class="row">
						<pre>
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								fun main() {
									val cat: Animal = Cat("meow") // Animal reference but Cat object
									cat.makeSound()
								}
							</code>
						</pre>
						<div class="column">
							Abstract class definition
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									/**
									 * Abstract class definition.
									 */
									abstract class Animal(
										protected val sound: String // notice the protected modifier
									) {

										/*
										Abstract method definition, which a subclass must implement.
										*/
										abstract fun makeSound()
									}
								</code>
							</pre>
						</div>
						<div class="column">
							Abstract class implementation
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									/**
									 * Subclass of Animal.
									 * Compiler will force us to call superclass constructor!
									 */
									class Cat(sound: String): Animal(sound) {

										/*
										Compiler will force us to use override keyword!
										*/
										override fun makeSound() {
											println(this.sound) // referencing sound in 'this' instance
										}
									}
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Interfaces</h3>
				<div class="summary">
					Interface is a reference type (like class) defined with the <code class="inline">interface</code> modifier.
				</div>
				<div class="content">
					<p>
						In Kotlin, an interface is a reference type similar to a class. It can contain abstract methods and properties, as well as default method implementations.
						Interfaces cannot store state and cannot have constructors. They are used to define a contract that classes can implement.
					</p>
					<p>
						Therefore, interface cannot be directly instantiated, just like abstract class. You could say interface is a 100% abstract class.
					</p>
					<ul>
						<li>Interfaces are declared using the <code class="inline">interface</code> keyword.</li>
						<li>All methods in an interface are abstract by default, but they can also have default implementations.</li>
						<li>Interfaces can contain properties, but these properties must be abstract or have default implementations.</li>
						<li>A class implements an interface using the <code class="inline">:</code> symbol followed by the interface name.</li>
						<li>A class can implement multiple interfaces, allowing for a form of multiple inheritance.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Interfaces</h3>
				<div class="content">
					<div class="row">
						<pre>Example:
							<code data-trim data-noescape data-line-numbers class="hljs kotlin">
								fun main() {
									val cat: Animal = Cat() // Animal reference but Cat object

									cat.makeSound()

									val distance = 3.2
									val movementTime = cat.move(distance)

									println("Cat move $distance m in $movementTime s")
								}
							</code>
						</pre>
						<div class="column">
							Interface
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									interface Animal {

										fun makeSound()

										fun move(double distance): Double

									}
								</code>
							</pre>
						</div>
						<div class="column">
							Implementation
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									class Cat : Animal {

										override fun makeSound() {
											println("meow")
										}

										fun move(double distance): Double {
											double speed = 2.0
											return distance / speed
										}
									}
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Interfaces</h3>
				<div class="summary">
					You can also implement multiple interfaces at once.
				</div>
				<div class="content">
					<div class="row">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									fun main() {
										val cat: Animal = Cat() // Animal reference but Cat object

										cat.makeSound()

										val distance = 3.2
										val movementTime = cat.move(distance)

										println("Cat move $distance m in $movementTime s")
									}
								</code>
							</pre>

						<div class="column">
							Moving interface
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									interface Moving {

										fun move(double distance): Double

									}
								</code>
							</pre>
							Vocalizing interface
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									interface Vocalizing {

										fun makeSound()

									}
								</code>
							</pre>
						</div>
						<div class="column">
							Implementation of both Moving and Vocalizing
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									class Cat : Moving, Vocalizing {

										override fun makeSound() {
											println("meow")
										}

										fun move(double distance): Double {
											double speed = 2.0
											return distance / speed
										}
									}
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Interfaces</h3>
				<div class="summary">
					You can also extend interface with other interfaces.
					The concrete class that implements such interface will be required to implement all abstract methods.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							Animal interface
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									interface Animal extends Moving, Vocalizing {

										fun eat(String food)

									}
								</code>
							</pre>
							Moving interface
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									interface Moving {

										fun move(double distance): Double

									}
								</code>
							</pre>
							Vocalizing interface
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									interface Vocalizing {

										fun makeSound()

									}
								</code>
							</pre>
						</div>
						<div class="column">
							Implementation of Animal
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									class Cat : Animal {

										override fun makeSound() {
											println("meow")
										}

										override fun move(double distance): Double {
											double speed = 2.0
											return distance / speed
										}

										override fun eat(String food) {
											println("eats " + food)
										}
									}
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Next Lesson</h2>
			</section>
			<section>
				<h3>Next Lesson</h3>
				<div class="summary">
					In the following lesson, we will learn the fundamentals of testing.
				</div>
				<div class="content">
					<p>
						We will cover:
					</p>
					<ul>
						<li>What is testing?</li>
						<li>Why do we test?</li>
						<li>Types of tests</li>
						<li>Levels of tests</li>
						<li>Test design techniques</li>
					</ul>
					<p>
						We will also write some tests using <strong>Kotest</strong>.
					</p>
				</div>
			</section>
		</section>
	</div>
</div>

<script src="./src/dist/reveal.js"></script>
<script src="./src/plugin/notes/notes.js"></script>
<script src="./src/plugin/markdown/markdown.js"></script>
<script src="./src/plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
